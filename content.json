{"posts":[{"title":"LeetCode日志","text":"Apri 14, 2024有效的括号C++语法复习 string s 属性: s.size() = s.length() 索引: s[i] 遍历: for(int i=0;i&lt;s.size();i++) or for(char ch: s) or for(auto ch: s) stack&lt; char &gt; stk 属性: stk.empty(), stk.top(), stk.pop(), stk.push(x) 方法: stk.pop() 不返回任何值 遍历: while(!stk.empty()) unordered_map&lt;char, char&gt; pairs 定义: 哈希表存储快速查找 12345unordered_map&lt;char, char&gt; pairs = { {')', '('}, {']', '['}, {'}', '{'}}; 方法: pairs.count(ch) 检测是否存在给定键的元素 索引: pairs[ch] Reference 最小栈C++语法复习 类构造 解题思路 设置辅助栈，维护当前栈中的最值； 1234567891011121314151617181920212223242526class MinStack { stack&lt;int&gt; x_stack; stack&lt;int&gt; min_stack;public: MinStack() { min_stack.push(INT_MAX); } void push(int x) { x_stack.push(x); min_stack.push(min(min_stack.top(), x)); } void pop() { x_stack.pop(); min_stack.pop(); } int top() { return x_stack.top(); } int getMin() { return min_stack.top(); }}; 字符串解码C++语法复习 string s 属性: string.size() 方法: s.substr(start, length) 提取子串 常用函数 isdigit(x) 判断是否为数字 isalpha(x) 判断是否为字母 to_string(x) 转换为字符串 stoi(x) 转换为整数 解题思路压栈时记录当前字符串的长度，出栈计算当前字符串长度，两个长度相减就是需要拼接的子串长度。 123456789101112131415161718192021222324252627class Solution {public: string decodeString(string s) { string ans; stack&lt;pair&lt;int, int&gt;&gt; stk; int count = 0; for (auto x : s) { if (isdigit(x)) count = 10 * count + (x - '0'); else if (x == '[') { stk.push({count, ans.size()}); count = 0; } else if (isalpha(x)) ans += x; else if (x == ']') { int n = stk.top().first; string str = ans.substr(stk.top().second, ans.size() - stk.top().second); for (int i = 0; i &lt; n - 1; i++) { ans += str; } stk.pop(); } } return ans; }}; Apri 16, 2024每日温度C++语法复习 vector&lt; int &gt; t 属性: t.size() 函数：vector&lt; int &gt; next_day(n); 创建一个大小为 n 的 vector&lt; int &gt; 数组 解题思路 单调栈 栈中存储元素的下标，维持一个每日温度单调递减的栈 遍历数组，当遇到比栈顶元素大的元素时，栈顶元素出栈，并计算出当前元素与栈顶元素之间的距离 遍历完成后，栈中剩余的元素即为无法找到对应元素的下标，其对应的下一天位置为初始化的 0 参考 栈进阶数据结构 12345678910111213141516class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { vector&lt;int&gt; next_day(temperatures.size()); stack&lt;int&gt; stk; stk.push(0); for(int i=1;i&lt;temperatures.size();i++){ while(!stk.empty() &amp;&amp; temperatures[stk.top()] &lt; temperatures[i]){ next_day[stk.top()] = i-stk.top(); stk.pop(); } stk.push(i); } return next_day; }}; Apri 22, 2024柱状图中最大的矩形C++语法复习 vector&lt; int &gt; t 函数：t.push_back(x) 添加元素 pair&lt; int, int &gt; make_pair(x, y) 解题思路 单调栈 栈中存储矩形&lt;宽, 高&gt;，维持一个高度递增的栈 遍历每一个矩形，若栈空或当前矩形高度高于栈顶矩形，直接进栈 若当前矩形高度小于栈顶矩形，则弹出栈顶矩形，累计其当前矩形厚度乘以其高度即为完全涵盖该矩形的最大矩形面积，直至栈空或当前矩形高度高于栈顶矩形； 参考 栈进阶数据结构 12345678910111213141516171819class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int max_size = 0; heights.push_back(0); // 保证最终栈空 stack&lt;pair&lt;int, int&gt;&gt; rang; for(int i=0;i&lt;heights.size();i++){ int cnt = 0; while(!rang.empty() &amp;&amp; rang.top().second &gt; heights[i]){ cnt += rang.top().first; max_size = max(max_size, cnt * rang.top().second); rang.pop(); } max_size = max(max_size, (cnt + 1) * heights[i]); rang.push(make_pair(cnt + 1, heights[i])); } return max_size; }}; Apri 23, 2024相交链表C++语法复习 结构体获取元素：Ta = Ta-&gt;next; unordered_set&lt;ListNode *&gt; visited; 创建无序集合，哈希数组（学会运用） make_pair(x, y) 解题思路 暴力解法 遍历两个链表，计算出各自长度，然后再对其链表指针，同时遍历 哈希解法 headA, headB地址为键值建立哈希数组，接下来检测是否存在该键值即可 双指针 利用两个指针分别遍历headA + headB，保证总遍历长度一致，将会找到最开始的公共节点 我的写法 —— 暴力解法 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *Ta = headA; ListNode *Tb = headB; int cnta = 0, cntb = 0; while(Ta){ Ta = Ta-&gt;next; cnta += 1; } while(Tb){ Tb = Tb-&gt;next; cntb += 1; } if(cnta &gt; cntb){ int temp = cnta-cntb; while(temp--){ headA = headA-&gt;next; } }else if(cntb &gt; cnta){ int temp = cntb-cnta; while(temp--){ headB = headB-&gt;next; } } while(headA &amp;&amp; headB){ if(headA == headB) return headA; headA = headA-&gt;next; headB = headB-&gt;next; } return headA; }}; 哈希解法 12345678910111213141516171819class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { unordered_set&lt;ListNode *&gt; visited; ListNode *temp = headA; while (temp != nullptr) { visited.insert(temp); temp = temp-&gt;next; } temp = headB; while (temp != nullptr) { if (visited.count(temp)) { return temp; } temp = temp-&gt;next; } return nullptr; }}; 双指针 1234567891011121314class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == nullptr || headB == nullptr) { return nullptr; } ListNode *pA = headA, *pB = headB; while (pA != pB) { pA = pA == nullptr ? headB : pA-&gt;next; pB = pB == nullptr ? headA : pB-&gt;next; } return pA; }}; Apri 30, 2024反转链表解题思路1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* nhead = NULL; while(head){ ListNode* temp = head-&gt;next; head-&gt;next = nhead; nhead = head; head = temp; } return nhead; }}; 回文链表解题思路 反转链表 先遍历链表获取链表长度 length 将前半部分链表进行反转，再与后半部分链表进行比对 复杂度分析 时间复杂度：O(2n) = O(n) 空间复杂度：O(1) 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { int length = 0; ListNode* temp = head; while(temp){ length++; temp = temp-&gt;next; } int mid = length / 2, cnt = 0; ListNode* nhead = NULL; while(cnt &lt; mid){ ListNode* temp = head-&gt;next; head-&gt;next = nhead; nhead = head; head = temp; cnt++; } if(length % 2) head = head-&gt;next; while(nhead){ if(nhead-&gt;val != head-&gt;val) return false; nhead = nhead-&gt;next; head = head-&gt;next; } return true; }}; 环形链表解题思路 哈希表: 判断存在该已访问过节点 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { unordered_set&lt;ListNode *&gt; visited; while(head != NULL){ if(visited.count(head)) return true; else{ visited.insert(head); head = head-&gt;next; } } return false; }}; 快慢指针：快指针追上满指针一圈 123456789101112131415161718class Solution {public: bool hasCycle(ListNode* head) { if (head == nullptr || head-&gt;next == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) { if (fast == nullptr || fast-&gt;next == nullptr) { return false; } slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return true; }}; 环形链表 II解题思路 哈希表 123456789101112131415class Solution {public: ListNode *detectCycle(ListNode *head) { unordered_set&lt;ListNode *&gt; visited; while(head != NULL){ if(visited.count(head)) return head; else{ visited.insert(head); head = head-&gt;next; } } return NULL; }}; 两数相加解题思路 模拟 1234567891011121314151617181920212223242526272829class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *head = nullptr, *tail = nullptr; int carry = 0; while (l1 || l2) { int n1 = l1 ? l1-&gt;val: 0; int n2 = l2 ? l2-&gt;val: 0; int sum = n1 + n2 + carry; if (!head) { head = tail = new ListNode(sum % 10); } else { tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; } carry = sum / 10; if (l1) { l1 = l1-&gt;next; } if (l2) { l2 = l2-&gt;next; } } if (carry &gt; 0) { tail-&gt;next = new ListNode(carry); } return head; }}; 删除链表的倒数第 n 个结点解题思路 模拟 获取链表长度，得到倒数第 n 个节点的前驱节点； 创建一个虚拟头节点，避免单个元素和两个元素的特异性； 1234567891011121314151617181920class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* nhead = new ListNode(-1); nhead-&gt;next = head; ListNode* ptr = nhead; int length = -1; while(ptr != NULL){ ptr = ptr-&gt;next; length++; } int pos = length - n; ptr = nhead; for(int i=0;i&lt;pos;i++){ ptr = ptr-&gt;next; } ptr-&gt;next = ptr-&gt;next-&gt;next; return nhead-&gt;next; }}; May 5, 2024两两交换链表中的节点解题思路 维护三个指针，pprev 用于更新前一翻转过的小节的 next 指针指向下一小节翻转后的首个节点； prev 用于当前小节的首指针，after 用于当前小节的尾指针 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode* pprev=NULL; ListNode* prev=head; if(head == NULL) return head; ListNode* after=head-&gt;next; while(after != NULL){ prev-&gt;next = after-&gt;next; after-&gt;next = prev; if(pprev == NULL){ head = pprev = after; pprev = pprev-&gt;next; } else{ pprev-&gt;next = after; pprev = pprev-&gt;next-&gt;next; } prev = prev-&gt;next; if(prev == NULL) after = NULL; else after = after-&gt;next-&gt;next-&gt;next; } return head; }}; May 8, 2024K 个一组翻转链表解题思路 单组处理：每一组都是翻转链表，只需要获取子链表的头节点合尾节点即可； 组间连接：保留上一组的尾节点，然后进行串接； 辅助头节点：引入辅助头节点用于模拟前面以及处理完毕的子链表； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { if(head == NULL) return head; ListNode* after=(ListNode*)malloc(sizeof(ListNode)); after-&gt;next = head; head = after; ListNode* first = after-&gt;next; // 子链表首节点 ListNode* second = after-&gt;next; // 子链表尾节点 while(after != NULL){ ListNode* subhead = NULL; second = first; for(int i=0;i&lt;k-1;i++){ // 获取子链表尾节点 if(second == NULL) break; second = second-&gt;next; } if(second){ // 翻转子链表 ListNode* nafter = first; ListNode* tag = second-&gt;next; do{ ListNode* temp = first-&gt;next; first-&gt;next = subhead; subhead = first; first = temp; }while(first != tag); after-&gt;next = subhead; after = nafter; }else{ // 否则串联 after-&gt;next = first; break; } } return head-&gt;next; }}; 随机链表的复制C++复习 字典：unordered_map&lt; Node*, Node*&gt;; 创建：new Node(val); 解题思路 哈希法：将原节点和新节点映射起来，然后根据原节点的random域获取新节点地址，进行串接； 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node {public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; }};*/class Solution {public: unordered_map&lt;Node*, Node*&gt; RanMap; Node* copyRandomList(Node* head) { if(head == NULL) return NULL; Node* newhead = new Node(head-&gt;val); Node* newptr = newhead; Node* ptr = head; while(ptr-&gt;next){ RanMap[ptr] = newptr; newptr-&gt;next = new Node(0); newptr = newptr-&gt;next; ptr = ptr-&gt;next; newptr-&gt;val = ptr-&gt;val; } RanMap[ptr] = newptr; ptr = head, newptr = newhead; while(ptr){ newptr-&gt;random = RanMap[ptr-&gt;random]; ptr = ptr-&gt;next; newptr = newptr-&gt;next; } return newhead; }}; May 20, 2024两数之和C++ 复习 unordered_map&lt; int, int &gt; dmap; 寻找元素: dmap.find(key) 如果找到返回元素迭代器否则返回末尾迭代器 解题思路12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; dset; for(int i=0;i&lt;nums.size();i++){ if(dset.find(target-nums[i]) != dset.end()){ return {dset[target-nums[i]], i}; } dset[nums[i]] = i; } return {}; }}; 字母异位词分组C++复习 for(string &amp;s:strs) 创建迭代器 解题思路 核心：不关系序列的顺序而重视其存在性，可以考虑使其进行排序； 123456789101112131415class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { vector&lt;vector&lt;string&gt;&gt; ans; unordered_map&lt;string, vector&lt;string&gt;&gt; alpha_set; for(string &amp;s:strs){ string temp(s.begin(), s.end()); sort(temp.begin(), temp.end()); alpha_set[temp].push_back(s); } for(auto &amp;x:alpha_set) ans.push_back(x.second); return ans; }}; 最长连续序列解题思路 先排序后遍历 12345678910111213141516171819202122class Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; vector&lt;int&gt; temp(nums.begin(), nums.end()); sort(temp.begin(), temp.end()); int ans = 0, last_val = temp[0], temp_len = 1; for(int i=1;i&lt;temp.size();i++){ if(temp[i] == last_val) continue; else if(temp[i] == (last_val + 1)){ temp_len++; last_val = temp[i]; } else{ ans = max(ans, temp_len); last_val = temp[i]; temp_len = 1; } } return max(ans, temp_len); }}; May 22, 2024移动零解题思路 双指针 Solution 1 123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int pos1 = 0, pos2 = 0; while(pos1 &lt;= pos2 &amp;&amp; pos2 != nums.size()){ if(nums[pos1] == 0 &amp;&amp; nums[pos2] != 0){ swap(nums[pos1], nums[pos2]); pos1++, pos2++; }else{ if(nums[pos1] != 0 ) pos1++; if(nums[pos2] == 0 || pos1 &gt;= pos2) pos2++; } } }}; Solution 2 1234567891011121314151617void swap(int* a,int*b){ int c = *a; *a = *b, *b = c;}void moveZeroes(int* nums, int numsSize) { int left = 0,right = 0; while(right&lt;numsSize) { if(nums[right]) { swap(nums+right,nums+left); left++; } right++; }}","link":"/%E4%B8%93%E4%B8%9A%E5%A4%8D%E4%B9%A0/LeetCode%E6%97%A5%E5%BF%97/"},{"title":"概率论与数理统计","text":"","link":"/%E4%B8%93%E4%B8%9A%E5%A4%8D%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"title":"Latex基本操作","text":"Latex学习一————基本结构1.1 主体结构源程序分为导言区和正文区，其中导言区设置文章的一些性质或自定义命令，选定文档类命令为 \\documentclass{article}，设置文章属性可以加入命令 \\title{},\\auther{},\\date{}正文区又称文稿区，设置文档环境命令 \\begin{document},\\end{document},一篇文档有且只能设置一个文档环境。 1.2 部分命令12345678910111213141516\\maketitle % 生成标题，用在`book/report/article`类的正文区中，而`letter`类在正文区并没有此命令。 $ $ % 单`$`命令主要用于行内公式书写 $$ $$ % 而双`$$`命令用于行间公式 \\tableofcontents % 输出文章目录 \\bibliographystyle % 声明参考文献的格式 \\footnote{} % 在正文后面设置脚注，花括号内的部分是命令的参数，即脚注的内容。 \\emph{} % 改变字体形状，表示强调(emphasis)的内容 \\begin{quote}% 将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。% 同时设置引用的字体\\zihao{-5}\\kaishu % 设置字号和字体命令 会影响后面所有文字(环境内)% 注：\\zihao{}有参数，-5即小五号\\end{quote}\\begin{abstract}文章摘要环境，在\\maketitle之后设置\\end{abstract} 例： 123456789101112131415% 导言区\\documentclass{article} % book,report,letter\\title{My First Document}\\author{MarkStiff}\\date{\\today}% 正文区(文稿区)\\begin{document} \\maketitle Hello World! % here is my big formula Let $f(x)$ be defined by the formula $$f(x)=3x^2+x-1$$ which is a polynomial of degree 2.\\end{document} 生成效果图: Latex学习二————中文文档设置2.1 文档整体设置 可以加入 \\usepackage{ctex}命令使用扩展包； 直接设置整体文档类 \\documentclass[UTF8]{ctexart},此外还有 ctexbook ctexrep 可选参数表明中文文档的编码，主要有 GBK和UTF8，不同 Latex编辑器默认编码方式不同。 2.2 equation环境123\\begin{equation}AB^2 = BC^2 + AC^2.\\end{equation} 此环境命令主要是用于产生带编号的行间公式。 2.4 章节设置\\section{章节标题}生成一节的标题 2.3 中文字体设置字体族设置——罗马字体、无衬线字体、打字机字体 字体命令 123\\textrm{文本} % 设置字体族为罗马字体\\textsf{文本} % 无衬线字体\\texttt{文本} % 打字机字体 字体声明命令 1234\\rmfamily 文本 % 声明以后的字体使用罗马字体\\sffamily 文本 % 无衬线字体\\ttfamily 文本 % 打字机字体{\\rmfamily 文本} % 使用括号限定字体声明范围 字体系列设置1Pass Latex学习三———— 杂谈3.1 定理环境文章定理之类的是用一类定理环境输出的，在使用之前需要在导言区做定义:\\newtheorem{thm}{定理}定理环境有一个指定定理名字的可选参数，示例: 123456\\begin{thm}[勾股定理]直角三角形斜边的平方等于两腰的平方和。可以用符号语言表述为······起源于6--7年份 % 表示数字范围时可以用两个减号来输出Latex中的短横线\\end{thm} 3.2 数学公式123456% 行间公式 行内公式 pass\\angle ACB = \\pi/2 % 角符号以及使用pi命令f_pump % '_' 命令下标设置f^2 % '^' 命令上标设置% 注：如果上下标不止一个符号则需要用花括号进行分组90^\\circ % 设置角度上标 实际效果如图: 3.3 使用图表 插图功能插图功能由 graphicx宏包提供，需要在导言区进行设置 \\usepackage{graphicx}具体的插图命令为： \\includegraphics[width=3cm]{xiantu.pdf}其中可选参数设置图片在文档中的宽度，第二个参数是图形的文件名（放在源文件所在目录）使用xelatex命令编译时，支持的图形格式包括PDF、PNG、JPG、FPS等图形放置通常将图像放置在一个浮动体中，处于一个可以变动相对位置的环境中 123456\\begin{figure}[ht] % 设置浮动体环境 \\centering % 表示后面的内容居中 \\includegraphics[scale=0.6]{cover.jpg} \\caption{博客封面设计图} % 给插图加自动编号和标题 \\label{fig:封面图} % 设置插图标签\\end{figure} 注：可选参数 ht表示浮动体可以出现在环境周围的文本所在处(here)和一页的底部(top)具体效果图如下： 制作表格设置表格环境 tabular： 123456789\\begin{tabular}{|rrr|} \\hline 直角边 $a$ &amp; 直角边 $b$ &amp; 斜边 $c$ \\\\ \\hline 3 &amp; 4 &amp; 5\\\\ \\hline 5 &amp; 12 &amp; 13\\\\ \\hline\\end{tabular} 注： 可选参数 |rrr|表示表格有三列，都是右对齐，行与行之间用 \\\\隔开，列于列之间用 &amp;隔开，表格中的横线用 \\hline绘制 表格环境设置，一般表格也放置在浮动体中，即 table环境 1234567891011121314\\usepackage{float}\\begin{table}[H] % 使用H参数表示设置表格不浮动，需要在导言区添加float宏包\\begin{tabular}{|lll|} \\hline 直角边 $a$ &amp; 直角边 $b$ &amp; 斜边 $c$ \\\\ \\hline 3 &amp; 4 &amp; 5\\\\ \\hline 5 &amp; 12 &amp; 13\\\\ \\hline\\end{tabular}%\\qquad % 此命令可以产生两个M宽度的空格($a^2 + b^2 = c^2$)\\end{table} 效果图: 3.4 图表引用 图片引用根据上文插图设置的标签属性可以很容易引用图片一个示例：图\\ref{fig:xiantu}是我国古代对勾股定理的一种证明。 公式引用公式添加标签示例: 123\\begin{equation}\\label{eq:gougu} % 设定公式标签名AB^2 = BC^2 + AC^2\\end{equation} 在正文中引用示例: (\\ref{eq:gougu})注意公式引用的括号要手动添加另解，使用宏包 amsmath,在导言区添加宏包，之后通过命令 \\eqref{eq:gougu}引用，并能自动产生括号 3.5 设计文章格式一般设置文章整体格式可以借用宏包直接进行处理，现列举较为常用的文章格式宏包: 1234567\\usepackage{gemetry} % 设计页面尺寸宏包\\geometry{a4paper,centering,scale=0.8} % 定义A4纸大小，版心居中，宽0.8倍\\usepackage[format=hang,font=small,texfont=it]{caption} % 改变图表标题格式% 设定图表标题悬挂对齐，整体用小字号，标题文本使用斜体（对汉字而言是楷书）\\usepackage[nottoc]{tocbibind} % 增加目录的项目% 宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身 自定义环境如果需要设置特定的段落环境，可以利用已有的环境在导言区构造新的环境，以达到增加格式控制的目的 123456789% 这里对引用(quote)环境重新设置，增加更多格式控制命令\\newenvironment{myquote} {\\begin{quote}\\kaishu\\zihao{-5}} {\\end{quote}}% 这里新环境由环境名字、环境开始代码和环境末尾代码三个参数，这样在导言区定义可以重复使用% 使用\\begin{myquote}text······\\end{myquote} 自定义命令在一些需要的地方，Latex给我们提供了自定义新的命令的代码，这极大地拓展了不同背景和领域使用的便利性。 123% 这里以角度上标为例\\newcommand\\degree{^\\circ} % 在导言区定义$90\\degree$ = $90^\\circ$ 插图版式调整后效果:","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/Latex%E5%AD%A6%E4%B9%A0/"},{"title":"Latex组织文本","text":"一、标点符号1.1 引号Latex使用 ‘’来表示引号，如果遇到连续使用单引号和双引号的情形，则需要使用 \\,命令隔开，会产生很小的间距 1.2 符号 - 数学减号 单独使用时表示连字符 两个连用时，是 en dash，表示数字范围 三个连用时，是 em dash，即破折号 ~符号命令：数学模式 $\\sim$ 1.3 省略号西文省略号: \\ldots或者 \\dots，在句中使用时直接命令，而在句末使用时要把省略号放进数学模式中。中文写作使用全角标点，一般由 xsCJK宏包控制，可以使用 \\punctstyle{}命令修改， 1.4 空格以字母命名的宏后面空格会被自动忽略掉，此时可以使用 \\ 命令添加或者添加一个空分组 {}分隔，或者 {\\TeX}包裹进来不可打断的空格(带子)用 ~表示，function ~$f(x)$西方文体中，句末标点和缩写标点问题Latex默认在大写字母的点看作缩写标记，小写字母后面的点看作句子结束而设置不同的点间隔；但当特殊情况时需要明确指定具体用法，示例: 123456Tinker et al.\\ made the double play. % '\\空格'命令放在'.'后直接分隔单词Tinker et al,made the double play. % 一般情况下标点后需加空格\\frenchspacing % 禁止标点后的额外间距Roman number XII\\@. Yes. % '\\@'命令放在'.'前面只处理'.'是句子结束点，之后再添加空格表示正常的句号标点 1.5 幻影空格12345% 幻影空格实际上起到占位作用，接受一个参数，生成与参数内容大小一样的空盒子% 类似的还有\\hphantom和\\vphantom表示水平竖直方向上的幻影MarkStiff\\phantom{神奇}速速隐形MarkStiff神奇速速显形 1.6 换行12\\\\[2cm] % 命令直接另起一行，上一行保持原样,可选参数设置换行后增加的额外垂直距离\\linebreak % 命令指定一行的断点，上一行仍按完整一行散开对齐 二、字体2.1 字体族格式命令带参数命令主要用于少量字体的更换，三种字体族对应的带参数命令，而声明命令主要用偶遇分组或环境中字体的整体更换. 123456789带参数命令 \\textrm{Roman font family} \\textsf{Sans serif font family} \\texttt{Typewriter font family}声明命令 {\\rmfamily Roman font family} {\\sffamily Sans serif font family} {\\ttfamily Typewriter font family} 效果图: 2.2 字体形状命令1234567891011带参数命令 \\textup{Upright shape} % 直立形状 \\textit{Italic shape} % 意大利形状 \\textsl{Slanted shape} % 倾斜形状 \\textsc{SMALL CAPITALS SHAPE} % 小型大写形状声明命令 {\\upshape Upright shape} {\\itshape Italic shape} {\\slshape Slanted shape} {\\scshape SMALL CAPITALS SHAPE} 效果图：倾斜形状一般是对符号直接倾斜产生的，而通常的“斜体”往往指意大利形状，数学公式的字体一般就使用意大利形状 2.3 字体系列命令1234567带参数命令 \\textmd{Medium series} % 中等字体，正文默认使用此系列 \\textbf{Bold extended series} % 加宽加粗声明命令 {\\mdseries Medium series} {\\bfseries Bold extended series} 2.4 字体坐标经上文介绍了字体的三个特征，综合起来构成了确定一种字体的三维坐标：族、形状、系列，不同组合会产生不同的字体效果。具体组合效果图:恢复普通字体在复杂的字体环境中，恢复普通字体就显得十分重要了。\\textnormal{文字} % 带参数命令{\\normalfont 文字} % 声明命令斜体校正在使用斜体声明 \\itshape、\\slshape时，最后一个倾斜的字体会超过右边界，使得间距过近；而用带参数命令 \\textit、\\textsl时，可以自动修正这个距离，也可以手工使用 \\/命令进行校正。禁止校正有时对于倾斜校正是不必要的，则应关闭带参数倾斜命令的自动校正功能:\\textit{M\\nocorr}M 通过添加命令 \\nocorr命令来关闭自动校正 2.5 中文字体族对于中文字体，一般只使用不同的字体族进行区分，选择中文字体族使用 \\CJKfamily命令在 ctex宏包及文档下有一些预定义，默认情况下配置了四种字体族： 1234{\\heiti 这是黑体}{\\songti 这是宋体}{\\kaishu 这是楷书}{\\fangsong 这是仿宋} 组合字体ctex宏包及文档类也定义了一些组合字体，可以让中文也具备使用粗体和意大利体功能，并且重定义 \\rmfamily使它同时对中文起作用默认的中文字体是 rm，正常字体是宋体，粗体是黑体，意大利体是楷体","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/Latex%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%84%E7%BB%87%E6%96%87%E6%9C%AC/"},{"title":"Latex篇章结构","text":"一、构建小节 小节 \\section{} 子小节 \\subsection{} 子子小节 \\subsubsection{} 生成目录 \\tableofcontents 换行 \\\\或者 \\par:产生新的段落具体效果如下图： 二、章节大纲命令 \\chapter{}在使用之前需要更换文本类型，设置 \\documentclass{ctexbook}","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/Latex%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84/"},{"title":"SOC微体系结构设计","text":"前言 阿里云盘资源链接 期末复习笔记","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/SOC%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"人工智能导论课程复习笔记","text":"阿里云盘资源链接 复习思维导图","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Markdown学习","text":"一、基本操作语法1.1 基本格式&lt;1&gt; 设置标题前后均留有空格 &lt;2&gt; 加粗: 加粗示例1（较推荐） 加粗示例2 &lt;3&gt; 斜体： 斜体示例1(较推荐） 斜体示例2 1.2 段落和换行没有空行示例第一行第二行 有空行示例第一行 第二行 段内换行第一行，如果在段内换行需要在结尾插入两个及以上的空格第二行 1.3 有序列表有序列表示例(数字序号+英文句号+空格+列表内容) 我有一个梦想 我有两个梦想 我有三个梦想 1.4 无序列表无序列表示例(*/+/- + 空格 + 列表内容) 使用星号 我有一个梦想 我有两个梦想 我有三个梦想（其他标记效果相同） 1.5 嵌套列表语法示例在第一层列表上，每一层多一个TAB键 我有一个梦想 你有一个梦想 她有一个梦想 他有一个梦想(有序列表类似可以互相嵌套） (建议使用-标记无序列表避免与粗体和斜体混淆) 1.6 分割线基本格式分割线由3个及以上的*/-/_来标记，对应效果不同。分割线示例 星号 减号 下画线 二、图片文件操作2.1 插入图片基本语法 本地图片（支持相对路径和绝对路径） 网络图片 2.2 链接基本语法文字链接链接文字经常使用的网站Google、Github 引用链接经常使用的网站Google、Github 语法说明如下： 链接标记可以有字母、数字、空格和标点符号； 链接标记不区分大小写； 定义的链接内容可以放在当前文件的任意位置，建议放在页尾； 当链接地址为网络地址时要以http/https开头，否则会被识别为本地地址。 网址链接在Markdown中，将网络地址或邮箱地址使用＜＞包裹起来会被自动转换为超链接。邮箱链接示例获取更多信息，请访问MarkStiff的邮箱LZH1314521ligao@163.com 链接标题如果想了解关于Markdown的更多信息，请查看Markdown指南 2.3 行内代码与代码块行内代码语法格式 Insert_Codes 使用 mkdir 文件夹命令创建文件夹 代码块语法格式：Tab键或4个空格开头 //注意代码块需要隔行 12345//创建链表typedef struct Node{ int data; struct Node* next;}node; 2.4 引用语法格式：&gt; + 引用内容语法说明如下： 多行引用也可以在每一行的开头都插入＞； 在引用中可以嵌套引用； 在引用中可以使用其他的Markdown语法； 段落与换行的格式在引用中也是适用的。 单行引用 基于改进的自约束差分进化算法的多目标优化模型 多行引用 引用MarkStiff的博客文章MarkStiff算法介绍 嵌套引用 多目标优化模型 差分进化算法 改进的自约束处理 2.5 转义介绍当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用 \\ 进行转义语法格式：\\特殊字符 `// 常见转义字符` \\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/"},{"title":"嵌入式程序设计课程实验源码及复习笔记","text":"前言 阿里云盘资源链接 博主是21级计科院的，在此澄清一下部分学长留存的实验经验： 实验比较基础，并不像之前所说非常棘手； 可以提前准备，但也没太大必要，认真做下午基本就能完全结束； 实验三代码需要自己编写，但结构清晰，较为容易； 思维导图 用 Qt 编写嵌入式 GUI 程序——加减乘除四则运算器设计头文件calculator.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#ifndef CALCULATOR_H#define CALCULATOR_H //对 calculator.h 头文件的声明#include &lt;QWidget&gt; //包含主窗体类#include &lt;QPushButton&gt; //包含按键类#include &lt;QVBoxLayout&gt; //包含垂直布局器类#include &lt;QHBoxLayout&gt; //包含水平布局器类#include &lt;QLineEdit&gt; //包含显示框类#include &lt;QStack&gt;class Calculator : public QWidget //计算器继承自主窗体类{ Q_OBJECT //必须加上这句，如果要调用信号，槽函数的操作的话public: Calculator(); //计算器类的构造函数 ~Calculator(); //计算器类的析构函数public slots: //定义各个按键按下后对应操作处理的槽函数 void zeroButtonPress(); void oneButtonPress(); void twoButtonPress(); void threeButtonPress(); void fourButtonPress(); void fiveButtonPress(); void sixButtonPress(); void sevenButtonPress(); void eightButtonPress(); void nineButtonPress(); void addButtonPress(); void subButtonPress(); void mulButtonPress(); void divButtonPress(); void clearButtonPress(); void equButtonPress();private: QLineEdit *operateEdit;//声明显示框 QPushButton *zeroButton;//声明数字按键¹ QPushButton *oneButton; QPushButton *twoButton; QPushButton *threeButton; QPushButton *fourButton; QPushButton *fiveButton; QPushButton *sixButton; QPushButton *sevenButton; QPushButton *eightButton; QPushButton *nineButton; QPushButton *clearButton;//声明运算符按键 QPushButton *addButton; QPushButton *subButton; QPushButton *divButton; QPushButton *mulButton; QPushButton *equButton; QHBoxLayout *firstLayout;//声明水平布局器，该布局器主要对 16 个按键进行布局 QHBoxLayout *secondLayout; QHBoxLayout *thirdLayout; QHBoxLayout *fourthLayout; QVBoxLayout *mainLayout;//声明垂直布局器，该布局器主要对主窗体上面的空间进行排布 QString expression; int precedence(QChar op); float calculator(float a,float b,QChar op);};#endif // CALCULATOR_H 源文件calculator.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421#include&quot;calculator.h&quot;Calculator::Calculator(){ operateEdit = new QLineEdit(this);//初始化显示框 operateEdit-&gt;setReadOnly(true); //设置显示框为只读 operateEdit-&gt;setText(tr(&quot;0&quot;));//初始化显示框显示数据为0 zeroButton = new QPushButton;//初始化按键 zeroButton-&gt;setText(tr(&quot;0&quot;));//设置按键上显示的标签，以下对按键相关的操作类似 oneButton = new QPushButton; oneButton-&gt;setText(tr(&quot;1&quot;)); twoButton = new QPushButton; twoButton-&gt;setText(tr(&quot;2&quot;)); threeButton = new QPushButton; threeButton-&gt;setText(tr(&quot;3&quot;)); fourButton = new QPushButton; fourButton-&gt;setText(tr(&quot;4&quot;)); fiveButton = new QPushButton; fiveButton-&gt;setText(tr(&quot;5&quot;)); sixButton = new QPushButton; sixButton-&gt;setText(tr(&quot;6&quot;)); sevenButton = new QPushButton; sevenButton-&gt;setText(tr(&quot;7&quot;)); eightButton = new QPushButton; eightButton-&gt;setText(tr(&quot;8&quot;)); nineButton = new QPushButton; nineButton-&gt;setText(tr(&quot;9&quot;)); clearButton = new QPushButton; clearButton-&gt;setText(tr(&quot;Clear&quot;)); addButton = new QPushButton; addButton-&gt;setText(tr(&quot;+&quot;)); subButton = new QPushButton; subButton-&gt;setText(tr(&quot;-&quot;)); mulButton = new QPushButton; mulButton-&gt;setText(tr(&quot;*&quot;)); divButton = new QPushButton; divButton-&gt;setText(tr(&quot;/&quot;)); equButton = new QPushButton; equButton-&gt;setText(tr(&quot;=&quot;)); firstLayout = new QHBoxLayout;//初始化水平布局器 firstLayout firstLayout-&gt;addWidget(zeroButton); //把按键 zeroButton 添加到 firstLayout firstLayout-&gt;addWidget(oneButton); //把按键 oneButton 添加到 firstLayout firstLayout-&gt;addWidget(twoButton); //把按键 twoButton 添加到 firstLayout firstLayout-&gt;addWidget(addButton); //把按键 threeButton 添加到 firstLayout，以下对水平布局器的操作类似 secondLayout = new QHBoxLayout; secondLayout-&gt;addWidget(threeButton); secondLayout-&gt;addWidget(fourButton); secondLayout-&gt;addWidget(fiveButton); secondLayout-&gt;addWidget(subButton); thirdLayout = new QHBoxLayout; thirdLayout-&gt;addWidget(sixButton); thirdLayout-&gt;addWidget(sevenButton); thirdLayout-&gt;addWidget(eightButton); thirdLayout-&gt;addWidget(mulButton); fourthLayout = new QHBoxLayout; fourthLayout-&gt;addWidget(nineButton); fourthLayout-&gt;addWidget(clearButton); fourthLayout-&gt;addWidget(equButton); fourthLayout-&gt;addWidget(divButton); mainLayout = new QVBoxLayout(this);//初始化垂直布局器 mainLayout mainLayout-&gt;addWidget(operateEdit); //把显示数据框 operateEdit 加到 mainLayout mainLayout-&gt;addLayout(firstLayout); //把水平布局器 firstLayout 添加到 mainLayout mainLayout-&gt;addLayout(secondLayout); //把水平布局器 secondLayout 添加到mainLayout mainLayout-&gt;addLayout(thirdLayout); //把水平布局器 thirdLayout 添加到 mainLayout mainLayout-&gt;addLayout(fourthLayout); //把水平布局器 fourthLayout 添加到 mainLayoutconnect(zeroButton,SIGNAL(clicked()),this,SLOT(zeroButtonPress()));//把按键 zeroButton 的按下事件同 zeroButtonPress()绑定到一起，以下操作类似 connect(oneButton,SIGNAL(clicked()),this,SLOT(oneButtonPress())); connect(twoButton,SIGNAL(clicked()),this,SLOT(twoButtonPress())); connect(threeButton,SIGNAL(clicked()),this,SLOT(threeButtonPress())); connect(fourButton,SIGNAL(clicked()),this,SLOT(fourButtonPress())); connect(fiveButton,SIGNAL(clicked()),this,SLOT(fiveButtonPress())); connect(sixButton,SIGNAL(clicked()),this,SLOT(sixButtonPress())); connect(sevenButton,SIGNAL(clicked()),this,SLOT(sevenButtonPress())); connect(eightButton,SIGNAL(clicked()),this,SLOT(eightButtonPress())); connect(nineButton,SIGNAL(clicked()),this,SLOT(nineButtonPress())); connect(addButton,SIGNAL(clicked()),this,SLOT(addButtonPress())); connect(subButton,SIGNAL(clicked()),this,SLOT(subButtonPress())); connect(mulButton,SIGNAL(clicked()),this,SLOT(mulButtonPress())); connect(divButton,SIGNAL(clicked()),this,SLOT(divButtonPress())); connect(equButton,SIGNAL(clicked()),this,SLOT(equButtonPress())); connect(clearButton,SIGNAL(clicked()),this,SLOT(clearButtonPress())); this-&gt;setWindowTitle(tr(&quot;Calculator&quot;));//设置窗体标题为 Calculator expression=&quot;&quot;;}Calculator::~Calculator(){ if (operateEdit != NULL) { delete operateEdit; operateEdit = NULL; } if (zeroButton != NULL) { delete zeroButton; zeroButton = NULL; } if (oneButton != NULL) { delete oneButton; oneButton = NULL; } if (twoButton != NULL) { delete twoButton; twoButton = NULL; } if (threeButton != NULL) { delete threeButton; threeButton = NULL; } if (fourButton != NULL) { delete fourButton; fourButton = NULL; } if (fiveButton != NULL) { delete fiveButton; fiveButton = NULL; } if (sixButton != NULL) { delete sixButton; sixButton = NULL; } if (sevenButton != NULL) { delete sevenButton; sevenButton = NULL; } if (eightButton != NULL) { delete eightButton; eightButton = NULL; } if (nineButton != NULL) { delete nineButton; nineButton = NULL; } if (clearButton != NULL) { delete clearButton; clearButton = NULL; } if (addButton != NULL) { delete addButton; addButton = NULL; } if (subButton != NULL) { delete subButton; subButton = NULL; } if (mulButton != NULL) { delete mulButton; mulButton = NULL; } if (divButton != NULL) { delete divButton; divButton = NULL; } if (equButton != NULL) { delete equButton; equButton = NULL; } if (firstLayout != NULL) { delete firstLayout; firstLayout = NULL; } if (secondLayout != NULL) { delete secondLayout; secondLayout = NULL; } if (thirdLayout != NULL) { delete thirdLayout; thirdLayout = NULL; } if (fourthLayout != NULL) { delete fourthLayout; fourthLayout = NULL; } if (mainLayout != NULL) { delete mainLayout; mainLayout = NULL; }}void Calculator::zeroButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression += &quot;0&quot;; } else { expression.append(&quot;0&quot;); } operateEdit-&gt;setText(expression);}void Calculator::oneButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;1&quot;; } else { expression.append(&quot;1&quot;); } operateEdit-&gt;setText(expression);}void Calculator::twoButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;2&quot;; } else { expression.append(&quot;2&quot;); } operateEdit-&gt;setText(expression);}void Calculator::threeButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;3&quot;; } else { expression.append(&quot;3&quot;); } operateEdit-&gt;setText(expression);}void Calculator::fourButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;4&quot;; } else { expression.append(&quot;4&quot;); } operateEdit-&gt;setText(expression);}void Calculator::fiveButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;5&quot;; } else { expression.append(&quot;5&quot;); } operateEdit-&gt;setText(expression);}void Calculator::sixButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;6&quot;; } else { expression.append(&quot;6&quot;); } operateEdit-&gt;setText(expression);}void Calculator::sevenButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;7&quot;; } else { expression.append(&quot;7&quot;); } operateEdit-&gt;setText(expression);}void Calculator::eightButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;8&quot;; } else { expression.append(&quot;8&quot;); } operateEdit-&gt;setText(expression);}void Calculator::nineButtonPress(){ if(expression.isEmpty() || expression.endsWith('0')) { expression = &quot;9&quot;; } else { expression.append(&quot;9&quot;); } operateEdit-&gt;setText(expression);}void Calculator::addButtonPress(){ if(!expression.isEmpty() &amp;&amp; !expression.endsWith('+') &amp;&amp; !expression.endsWith('-') &amp;&amp; !expression.endsWith('*') &amp;&amp; !expression.endsWith('/')) { expression.append(&quot;+&quot;); } operateEdit-&gt;setText(expression);}void Calculator::subButtonPress(){ if(!expression.isEmpty() &amp;&amp; !expression.endsWith('+') &amp;&amp; !expression.endsWith('-') &amp;&amp; !expression.endsWith('*') &amp;&amp; !expression.endsWith('/')) { expression.append(&quot;-&quot;); } operateEdit-&gt;setText(expression);}void Calculator::mulButtonPress(){ if(!expression.isEmpty() &amp;&amp; !expression.endsWith('+') &amp;&amp; !expression.endsWith('-') &amp;&amp; !expression.endsWith('*') &amp;&amp; !expression.endsWith('/')) { expression.append(&quot;*&quot;); } operateEdit-&gt;setText(expression);}void Calculator::divButtonPress(){ if(!expression.isEmpty() &amp;&amp; !expression.endsWith('+') &amp;&amp; !expression.endsWith('-') &amp;&amp; !expression.endsWith('*') &amp;&amp; !expression.endsWith('/')) { expression.append(&quot;/&quot;); } operateEdit-&gt;setText(expression);}void Calculator::clearButtonPress(){ expression.clear(); operateEdit-&gt;setText(&quot;0&quot;);}//等号操作响应函数void Calculator::equButtonPress(){ if(expression.isEmpty()) { return; } QStack&lt;float&gt; numbers; QStack&lt;QChar&gt; operators; QString number; for(int i = 0; i &lt; expression.size(); ++i) { QChar c = expression.at(i); if(c.isDigit() || c == '.') { number.append(c); } else { if(!number.isEmpty()) { numbers.push(number.toFloat()); number.clear(); } while(!operators.isEmpty() &amp;&amp; precedence(operators.top()) &gt;= precedence(c)) { float second = numbers.pop(); float first = numbers.pop(); QChar op = operators.pop(); numbers.push(calculator(first, second, op)); } operators.push(c); } } if(!number.isEmpty()) { numbers.push(number.toFloat()); } while(!operators.isEmpty()) { float second = numbers.pop(); float first = numbers.pop(); QChar op = operators.pop(); numbers.push(calculator(first, second, op)); } float result = numbers.pop(); expression = QString::number(result, 'f', 7); operateEdit-&gt;setText(expression);}int Calculator::precedence(QChar op){ if(op == '+' || op == '-') { return 1; } else if(op == '*' || op == '/') { return 2; } return 0;}float Calculator::calculator(float a, float b, QChar op){ switch(op.toLatin1()) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; } return 0;} 主函数main.cpp123456789#include &lt;QApplication&gt;//包含应用程序类#include &quot;calculator.h&quot;//包含计算器类int main(int argc, char *argv[])//main 函数的标准写法{ QApplication app(argc, argv); //创建一个 QApplication 对象，管理应用程序的资源 Calculator mainwindow; //产生一个计算器对象 mainwindow.showMaximized();//显示计算器窗体(默认以最大化的形式显示) return app.exec();//让程序进入消息循环，等待可能的菜单、工具条、鼠标等的输入，} 编写嵌入式 Linux 设备驱动程序——LED驱动程序Notes insmod led_driver.ko 加载 LED 驱动模块 lsmod 查看目标机中已经加载的所有模块 cat /proc/devices 查看目标机中已经加载的所有设备，包括字符设备、块设备 rmmod led_driver.ko 卸载 LED 驱动模块 mknod /dev/XXX c #### x 创建 LED 设备文件节点 XXX 表示设备名，Linux 根据设备名创建设备目录；本实验中表示 led_light2 即指 LED 设备的第二个驱动程序，默认驱动程序为 led_light; c 表示字符设备 #### 表示主设备号 x 表示次设备号 ls /dev 查看创建的所有设备 rmmod led_driver.ko 卸载 LED 驱动模块 Codes Modification实验手册中给定的模块删除代码为： 12345678910/*模块的退出*/static void __exit s5pv210_led_exit(void){/* -------------------------------- */device_destroy(led_dev_class,DEVICE_NODE);/* ---------------------------------- */class_destroy(led_dev_class);cdev_del(cdev_p);unregister_chrdev_region(num_dev,1);} 根据设备文件节点是无法移除设备的，Linux 通过分配的设备号（主设备号、次设备号）来注册设备的，因此需要删除设备对应的设备号 num_dev，修改后的代码为： 12345678910/*模块的退出*/static void __exit s5pv210_led_exit(void){/* -------------------------------- */device_destroy(led_dev_class,num_dev);/* ---------------------------------- */class_destroy(led_dev_class);cdev_del(cdev_p);unregister_chrdev_region(num_dev,1);} 模块驱动程序led_driver.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/sched.h&gt;#include&lt;linux/kernel.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;plat/gpio-cfg.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/fs.h&gt; #include &lt;linux/device.h&gt;/*定义设备目录*/#define DEVICE_LIST &quot;led_test2&quot;/*定义设备文件节点*/#define DEVICE_NODE &quot;led_light2&quot;#define LED1 0x01#define LED2 0x02#define LED3 0x04#define LED4 0x08/*定义申请设备号(主设备号+次设备号)的变量*/static dev_t num_dev; /*字符设备的变量定义*/static struct cdev *cdev_p;/*定义一个 class 类*/static struct class *led_dev_class;/*定义一个全局变量，表示 LED 灯的状态*/static unsigned char led_status = 0;/*设置 LED 灯的状态*/static void set_led_status(unsigned char status){/*表示 LED 灯的状态是否发生变化*/unsigned char led_status_changed;led_status_changed= led_status^(status &amp; 0xF);/*数据变化检测*/led_status=(status &amp; 0xF);/*如果 4 个 LED 灯的状态发生了变化*/if(led_status_changed!=0x00){/*判断是否改变 LED1 灯的状态*/if(led_status_changed&amp;LED1){if(led_status&amp;LED1)gpio_direction_output(S5PV210_GPH0(0),0);elsegpio_direction_output(S5PV210_GPH0(0),1);}/*判断是否改变 LED2 灯的状态*/if(led_status_changed&amp;LED2){if(led_status&amp;LED2)gpio_direction_output(S5PV210_GPH0(1),0);elsegpio_direction_output(S5PV210_GPH0(1),1);}/*判断是否改变 LED3 灯的状态*/if(led_status_changed&amp;LED3){if(led_status&amp;LED3)gpio_direction_output(S5PV210_GPH0(2),0);elsegpio_direction_output(S5PV210_GPH0(2),1);}/*判断是否改变 LED4 灯的状态*/if(led_status_changed&amp;LED4){if(led_status&amp;LED4)gpio_direction_output(S5PV210_GPH0(3),0);elsegpio_direction_output(S5PV210_GPH0(3),1);} } }/*读取 LED 灯的状态*/static ssize_t s5pv210_led_read(struct file * file,char * buf,size_t count,loff_t * f_ops){ /*从用户空间读取数据,获取 LED 灯的状态*/ copy_to_user(buf, (char *)&amp;led_status, sizeof(unsigned char)); return sizeof(unsigned char); }/*定义实现 LED 灯的写操作*/static ssize_t s5pv210_led_write (struct file * file,const char * buf, size_t count,loff_t * f_ops){unsigned char status;if(count==1){/*向用户空间写数据,如果写失败，则返回错误*/if(copy_from_user(&amp;status, buf,sizeof(unsigned char)))return -EFAULT;set_led_status(status);return sizeof(unsigned char); }else return -EFAULT;}/*打开 LED 设备*/static ssize_t s5pv210_led_open(struct inode * inode,struct file * file){ /*增加管理此设备的 owner 模块的使用计数*/try_module_get(THIS_MODULE);return 0;}/*释放 LED 设备*/static ssize_t s5pv210_led_release(struct inode * inode, struct file * file){/*减少管理此设备的 owner 模块的使用计数*/module_put(THIS_MODULE);return 0;}/*定义具体的文件操作*/static const struct file_operations s5pv210_led_ctrl_ops={ .owner = THIS_MODULE, .open = s5pv210_led_open, .read = s5pv210_led_read, .write = s5pv210_led_write, .release = s5pv210_led_release,};/*LED 灯的初始化和 LED 设备驱动的加载*/static int s5pv210_led_ctrl_init(void){int err;struct device* temp=NULL;unsigned int gpio;/*GPIO 口的初始化 LED1,LED2,LED3,LED4，设置为输出*/for(gpio=S5PV210_GPH0(0);gpio&lt;S5PV210_GPH0(4);gpio++){s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(1));}/*动态注册 led_test 设备,num_dev 为动态分配出来的设备号(主设备号+次设备号)*/err=alloc_chrdev_region(&amp;num_dev,0,1,DEVICE_LIST);if (err &lt; 0) {printk(KERN_ERR &quot;LED: unable to get device name %d/n&quot;, err);return err;}/*动态分配 cdev 内存空间*/cdev_p = cdev_alloc();cdev_p-&gt;ops = &amp;s5pv210_led_ctrl_ops;/*加载设备驱动*/err=cdev_add(cdev_p,num_dev,1);if(err){printk(KERN_ERR &quot;LED: unable to add the device %d/n&quot;, err);return err;}/*在/sys/class 下创建 led_test 目录*/led_dev_class=class_create(THIS_MODULE,DEVICE_LIST);if(IS_ERR(led_dev_class)){ err=PTR_ERR(led_dev_class);goto unregister_cdev;}/*基于/sys/class/led_test 和/dev 下面创建 led_light 设备文件*/temp=device_create(led_dev_class, NULL,num_dev, NULL, DEVICE_NODE);if(IS_ERR(temp)){err=PTR_ERR(temp);goto unregister_class;}return 0;unregister_class:class_destroy(led_dev_class);unregister_cdev:cdev_del(cdev_p);return err;}/*模块的初始化*/static int __init s5pv210_led_init(void){int ret;ret = s5pv210_led_ctrl_init();if(ret){printk(KERN_ERR &quot;Apply: S5PV210_LED_init--Fail !!!/n&quot;);return ret;}return 0;}/*模块的退出*/static void __exit s5pv210_led_exit(void){device_destroy(led_dev_class,num_dev);class_destroy(led_dev_class);cdev_del(cdev_p);unregister_chrdev_region(num_dev,1);}MODULE_LICENSE(&quot;GPL&quot;);MODULE_DESCRIPTION(&quot;LED driver test&quot;);module_init(s5pv210_led_init);module_exit(s5pv210_led_exit); Makefile1234567891011121314INSTALLDIR= /opt/tftpifneq ($(KERNELRELEASE),)obj-m:=led_driver.oelseKERNELDIR:=/opt/cross-compiler/kernel-embv210PWD:=$(shell pwd)default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesclean: rm -rf *.o *.order .*.cmd *.ko *.mod.c *.symversendifinstall: led_driver.ko mkdir -p $(INSTALLDIR) cp --target-dir=$(INSTALLDIR) led_driver.ko 测试文件led_test.c12345678910111213141516171819202122232425262728293031323334// LED test programme#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define DEVICE_NODE &quot;/dev/led_light2&quot;int main(int argc,char **argv){int fd,i,j;unsigned char status;unsigned char t;/*打开设备节点*/fd = open(DEVICE_NODE,O_RDWR);if(fd == -1) {printf(&quot;open device %s error \\n&quot;,DEVICE_NODE);return -1;}for(i=0;i&lt;3;i++){for(j=0;j&lt;4;j++){//依次点亮 LED1..LED4t=(unsigned char)((1&lt;&lt;j)&amp;0x0F);write(fd,&amp;t,sizeof(t));if(read(fd,&amp;status,1)!=0){printf(&quot;led status:%0x\\n&quot;,status);}sleep(1);} }close(fd);return 0;}","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"微机原理与系统设计课程设计实验报告","text":"博主是21级计科院的，分享自己的微机原理与系统设计课程设计实验报告。微机原理与系统设计总评：93分。","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"title":"微机原理与系统设计课程设计","text":"博主是21级计科院的，分享自己的微机原理与系统设计课程设计实验报告。","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"title":"扩散模型的基本原理与公式推导","text":"扩散模型(Diffusion Model)通过连续添加高斯噪声来破坏训练数据，然后通过反转这个噪声过程，来学习恢复数据。主要包括以下两个过程， 正向扩散过程 $q$: 逐渐将高斯噪声添加到图像中，直到最终得到纯噪声； 逆向去噪过程 $p_{\\theta}$: 通过训练神经网络从纯噪声开始逐渐对图像去噪，直到最终得到一个实际的图像。 前向过程(扩散过程)条件概率分布通过在 $T$ 个有限时间步内不断对图像添加高斯噪声设最初的图像样本 $x_0$，对应的真实数据分布为 $x_0\\sim q(x_0)$，并且控制每个时间步对应的缩放因子有如下关系：$$0&lt;\\beta_1&lt;\\beta_2&lt;\\cdots&lt;\\beta_T=1\\tag{1}$$给定样本的前一步状态$x_{t-1}$，可以得到当前状态$x_t$的条件概率分布:$$q(x_t|x_{t-1}) = N(x_t;\\sqrt{1-\\beta_t}x_{t-1}, \\beta_t I)\\tag{2}$$其中，$N(\\mu, \\sum)$表示多维正态分布，均值为$\\mu$，协方差矩阵为$\\sum$，提取的样本特征$x$为多维变量，因此表示为多维正态分布。直接的含义解释，设定缩放因子$\\beta_t$缩放前一步的样本特征$x_{t-1}$，并在样本特征的多个维度上添加独立同分布的噪声（单位矩阵）。 扩散过程可以表示为：$$q(x_{1:T}|x_0) = \\prod_{t=1}^T q(x_t|x_{t-1})\\tag{3}$$ Theory 1 重参数 (Reparameterization Trick)多维随机变量 $z$ 服从分布 $z\\sim N(z;\\mu_{\\theta}, \\sigma_{\\theta}^2 I)$，则可以将其进一步表示为$$z=\\mu_{\\theta} + \\sigma_{\\theta} \\cdot \\epsilon, \\epsilon \\sim N(0, I)\\tag{4}$$ $z$ 的随机性转移为 $\\epsilon$ 的随机性。 概率分布推导Supposing $x_0\\sim N(x_0;\\mu_0, \\sigma_0^2 I)$, then$$x_t = \\sqrt{1-\\beta_t}x_{t-1} + \\beta_t \\epsilon_{t-1}\\tag{5}$$令 $\\alpha_t = 1-\\beta_t$, then$$\\begin{aligned}x_t &amp;= \\sqrt{\\alpha_t} x_{t-1} + \\sqrt{1-\\alpha_t}\\epsilon_{t-1} \\newlinex_{t-1} &amp;= \\sqrt{\\alpha_{t-1}} x_{t-2} + \\sqrt{1-\\alpha_{t-1}}\\epsilon_{t-2}\\end{aligned}\\tag{6}$$故$$\\begin{aligned}x_t &amp;= \\sqrt{\\alpha_t}(\\sqrt{\\alpha_{t-1}}x_{t-2} + \\sqrt{1-\\alpha_{t-1}}\\epsilon_{t-2})+\\sqrt{1-\\alpha_t}\\epsilon_{t-1}\\newline &amp;= \\sqrt{\\alpha_{t-1}\\alpha_t} x_{t-2} + \\sqrt{\\alpha_t}\\sqrt{1-\\alpha_{t-1}}\\epsilon_{t-2}+\\sqrt{1-\\alpha_t}\\epsilon_{t-1}\\end{aligned}\\tag{7}$$For $\\sqrt{\\alpha_t}\\sqrt{1-\\alpha_{t-1}}\\epsilon_{t-2}$ 可表示为$$z_1 = 0 + \\sqrt{\\alpha_t}\\sqrt{1-\\alpha_{t-1}}\\epsilon_{t-2}\\sim N(0, \\alpha_t(1-\\alpha_{t-1}) I)\\tag{8}$$For $\\sqrt{1-\\alpha_{t}}\\epsilon_{t-1}$ 可表示为$$z_2 = 0 + \\sqrt{1-\\alpha_t}\\epsilon_{t-1}\\sim N(0, (1-\\alpha_t) I)\\tag{9}$$Theory 2 两个正态随机变量和 $z =z_1+z_2$Conditions: $z_1 \\sim N(\\mu_1, \\sigma^2_1), z_2 \\sim N(\\mu_2, \\sigma^2_2), Cov(z_1, z_2) = 0$Conclusions:$$EZ = EZ_1 + EZ_2 = \\mu_1 + \\mu_2\\newlineDZ = DZ_1 + DZ_2 + 2Cov(z_1, z_2) = \\sigma^2_1 + \\sigma^2_2\\tag{10}$$记 $z=z_1+z_2\\sim N(0, (1-\\alpha_t\\alpha_{t-1})I)$，则可得$$\\begin{aligned}x_t &amp;= \\sqrt{\\alpha_{t-1}\\alpha_t}x_{t-2} + \\sqrt{1-\\alpha_t\\alpha_{t-1}}\\epsilon_{t-2}\\newline&amp;=\\cdots\\newline&amp;=\\sqrt{\\alpha_t\\alpha_{t-1}\\cdots\\alpha_1}x_0 + \\sqrt{1-\\alpha_t\\alpha_{t-1}\\cdots\\alpha_1}\\epsilon_0\\newline&amp;=\\sqrt{\\overline{\\alpha_t}}x_0 + \\sqrt{1-\\overline{\\alpha_t}}\\epsilon\\end{aligned}\\tag{11}$$其中，$\\overline{\\alpha_t} = \\prod_{i=1}^t\\alpha_i$.进一步结合公式 (2)，可以得到在初始状态条件下的第 $t$ 步的概率分布$$q(x_t|x_0) =N(x_t; \\sqrt{\\overline{\\alpha_t}}x_0, \\sqrt{1-\\overline{\\alpha_t}}I)\\tag{12}$$Analysis of $\\beta_i$:已知 $0 &lt; \\beta_1 &lt; \\beta_2 &lt; \\cdots &lt; \\beta_T = 1$，则$$1 &gt; \\alpha_1 &gt; \\alpha_2 &gt; \\cdots &gt; \\alpha_T &gt; 0\\tag{13}$$当 $\\alpha$ 满足收敛性时，$\\exists T &gt; 0, \\epsilon &gt; 0$, 当 $t &gt; T$ 时, $|\\overline{\\alpha_t} - 0| &lt; \\epsilon$, 则$$\\begin{aligned}x_t &amp;= \\sqrt{\\overline{\\alpha_t}}x_0 + \\sqrt{1-\\overline{\\alpha_t}}\\epsilon\\newline&amp;\\sim N(\\sqrt{\\overline{\\alpha_t}}x_0, (1-\\overline{\\alpha_t}) I)\\newline&amp;\\overset{t&gt;T}{\\longrightarrow} N(0, 1)\\end{aligned}\\tag{14}$$ 反向过程(逆扩散过程)$$p(x_0|x_{1:T}) = \\frac{1}{Z} \\exp(-\\beta_t \\cdot \\frac{1}{2} \\cdot (x_t - \\sqrt{1-\\beta_t}|x_{t-1})^2)$$","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/"},{"title":"数字信号处理课程复习笔记","text":"博主是21级计科院的，分享自己的数字信号处理课程复习笔记。任课教师：王文俊，课程成绩：89分","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"title":"数据库系统课程期末复习笔记及实验报告","text":"博主是21级计科院的，分享自己期末整理的复习笔记。任课教师：李翠敏 博主是21级计科院的，分享自己的数据库系统课程实验报告。实验指导老师：李翠敏 a'q","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"组合数学科技论文","text":"博主是21级计科院的，分享自己的组合数学科技论文。任课教师：纪建","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"title":"自主可控嵌入式系统复习笔记","text":"博主是21级计科院的，分享自己的自主可控嵌入式系统复习笔记，仅需此一份笔记而无需听课。任课教师：陈勉，课程成绩：97分","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E8%87%AA%E4%B8%BB%E5%8F%AF%E6%8E%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"自主可控嵌入式系统实验报告","text":"博主是21级计科院的，分享自己的自主可控嵌入式系统实验报告。任课教师：陈勉，课程成绩：97分 实验一 实验二 实验三 实验四 实验五","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E8%87%AA%E4%B8%BB%E5%8F%AF%E6%8E%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"计算机组成与体系结构设计实验报告","text":"博主是21级计科院的，分享自己的计算机组成与体系结构设计实验报告。实验指导老师：刘博，课设成绩：98分","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"title":"软件工程期末复习笔记","text":"阿里云盘资源链接 期末复习笔记","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"title":"基本不等式","text":"第六讲、不等式知识点 六、典型例题1pass","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"title":"导数与微分","text":"第四讲、导数与微分 隐函数存在定理 四、典型例题4.1 由方程组求导数 4.2 等价展开式处理 4.3 $Taylor$公式求导数 4.4 $Leibniz$公式运用 4.4.1 求高阶导数 4.4.2 综合运用 4.5 单侧倒数与可导性 4.6 多元函数连续性与可导性 4.7 偏导数与全微分注解：当函数$u=f(x,y,z)$对$\\theta$偏导数等于零时，则说明函数与该变量无关（或不含有或为常量）；注解：信息挖掘，$F(rcos\\theta,rsin\\theta)=h(r)$，根据$h(r)$不含有$theta$可得对$\\theta$偏导数等于零，于是$F$对于$\\theta$偏导数也等于零； 4.8 方向导数与梯度注解：注意坐标转换；","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"},{"title":"导数的综合应用","text":"第七讲、导数的综合应用知识点注解：式中 $$\\frac{\\partial(F,G)}{\\partial(y,z)}=\\left|\\begin{array}{c}F_y &amp; F_z\\G_y &amp; G_z \\end{array}\\right|$$ 七、典型例题7.1 方程实根的讨论 7.2 导数几何应用 7.3 函数极值与最值注解：思路分析——将乘积项拆分为点积，进一步得到函数驻点注解：注意求最值时改用参数方程的方法；注解：中值定理的使用，以及 $r = \\sqrt{x^2+y^2}$ 的使用；","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/%E5%AF%BC%E6%95%B0%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/"},{"title":"常微分方程","text":"第十八讲、微分中值定理知识点 十八、典型例题","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"},{"title":"微分中值定理","text":"第五讲、微分中值定理 五、典型例题5.1 中值定理极限讨论 5.2 含一个中值的等式证明注解：【罗尔定理】怎样由待证明等式构造函数，寻找两个零点；以及原函数与二阶导数同时存在时怎样利用一阶导数构造函数； 【一道经典题目】 注解：泰勒公式运用以及两端点泰勒展开式作差，最值定理以及介值定理； 注解：整体思路和上一道题目类似，特别注意积分上限函数的运用以及连续导数； 注解：怎样由三角函数结合待证明等式构造辅助函数，寻找两个零点； 5.3 含多个中值的等式证明注解：$F(x)$怎样构造的，借助$f(a+b-x)$巧妙地利用条件$f(a)=0$构造$F(b)=0$，以及构造$m、n$作为函数指数； 注解：这道题目准备工作很重要，设定$c = a/(a+b)$以及介值定理$f(\\mu)=c$； 【同型题目】 柯西中值定理 5.4 含中值不等式的证明极限保号性注解：这一类题目注重拉格朗日中值定理的应用，因为通过$Lagrange$中值定理可以判断取值范围； 反证法注解：构造$x^\\alpha G(x)$特别好，从不等式（导函数）中构造原函数；以及最后再次构造原函数，这道题目连续多次构造处理； 5.5 利用中值定理证明函数性质注解：此道题目对$f(x+\\theta h)$的二阶导函数再次泰勒展开，以及在区$h-&gt; 0$特别好； 注解：在处理$g^`(x)=0$时，设定$g(x)$极限为$L$或无穷大；之后假设证明：求极限问题；注解：带绝对值类的题目，对不等式而言尽可能放缩，注意其中二阶导数放缩不大于函数值与一阶导数值之和； 【拓展】注解：怎样求$f(x)$的导数，以及注意$f(0)$的导数需单独求解，另外对原函数等价于导数的积分处理进一步放缩特别好；","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"},{"title":"积分学","text":"第八讲 不定积分与定积分的计算知识点注解：（式5证明——区间对称性) $$\\int_a^b\\frac{f(x)}{f(x)+f(a+b-x)}dx=\\int_b^a\\frac{f(a+b-x)}{f(a+b-x)+f(x)}(-dx)$$ $$= \\frac{1}{2}\\int_a^b\\frac{f(x)+f(a+b-x)}{f(x)+f(a+b-x)}dx=\\frac{b-a}{2}$$ 八、典型例题8.1 不定积分计算【欧拉变换】【根式换元】【分部积分】【三角换元】注解： $$\\int\\frac{1}{(1+x^2)^{3/2}}dx = \\frac{x}{\\sqrt{1+x^2}}$$ 【构造函数】——凑微分（注意以下两种凑微分相同的方式）【参数方程】——借助参数方程转变为单变量积分注解：最后一道题中需要注意： $$1-y^4=(1-y)(1+y+y^2+y3)$$ 8.2 定积分的计算【构造奇偶函数】【区间对称性】","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/%E7%A7%AF%E5%88%86%E5%AD%A6/"},{"title":"KMPAlgorithm","text":"Next数组设主串 S, 模式串 T, 则 Next[j] = k 表示当模式串的第 i 个字符发生失配时，即 S[i] $\\neq$ T[j], 则下一个需匹配的位置为 k, 即继续比较 S[i] 与 T[k] 保证主串指针 i 不回溯。 求解 Next 数组 若有 Next[j] = k, 求 Next[j+1] Next[j] = k 解释：S[i] $\\neq$ T[j] $\\Longrightarrow$ Compare(S[i], T[k]), 且 S[i-k,…,i-1] = T[1,…,k-1] 若 T[j+1] = T[j], j = next[j], 则可以延续上一个匹配位置一个字符，可以理解为公共子串增一，因此 Next[j+1] = j+1; 123456789101112void get_next(string t, int &amp;next[]){ int i=1, j=0; next[1] = 0; while(i &lt;= strlen(T)){ if(j == 0 || T[i] == T[j]){ i++, j++; next[i] = j; } else j = next[j]; }} 改进 Next 数组12345678910111213void get_nextval(string T, int &amp;nextval[]){ int i=1, j = 0; nextval[1] = 0; while(i &lt; strlen(T)){ if(j==0||T[i] == T[j]){ ++i, ++j; if(T[i] != T[j]) nextval[i] = j; else nextval[i] = nextval[j]; } else j = nextval[j]; }}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMPAlgorithm/"},{"title":"二叉树","text":"二叉树（Binary Tree)三种遍历算法基于链表结构实现的二叉树又称二叉链表，本文主要介绍二叉树的存储以及先序遍历、中序遍历和后序遍历三种遍历方式的递归和非递归算法： 二叉树构造二叉树抽象数据类型定义—— 基于链表实现 12345678//----------二叉树的二叉链表存储表示--------------typedef char TElemType;typedef bool Status;// 树节点定义typedef struct BiTNode { TElemType data; struct BiTNode* lchild, * rchild;}BiTNode, * BiTree; 二叉树递归构造： 通过指定按照满二叉树的节点输入顺序进行输入，对空树以 ‘.’ 表示 123456789101112131415/*---------------------二叉树创建函数------------------*/Status CreateBiTree(BiTree&amp; T){ // 递归读入二叉树的各元素，因此最开始的T还是指向根节点 TElemType ch; cin &gt;&gt; ch; if (ch == '.') T = NULL; else { if (!(T = (BiTree)malloc(sizeof(BiTNode)))) return false; T-&gt;data = ch; // 生成根节点 CreateBiTree(T-&gt;lchild); // 递归构造左子树 CreateBiTree(T-&gt;rchild); // 递归构造右子树 } return true;} 二叉树操作算子对二叉树的遍历往往是一个广泛的概念，遍历是对二叉树的每一个节点做一系列操作，其中最简单的就是输出节点数据域，这里只是以输出函数为例说明问题。 123456Status TreeTransOperator(TElemType e) // 二叉树遍历算子{ // 对数据元素操作的应用函数 cout &lt;&lt; e &lt;&lt; &quot; &quot;; return true;} 递归算法总体而言，递归算法较为简单，只需更换二叉树节点三部分的顺序即可，但需要注意的是左子树始终在右子树之前遍历； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//--------------------递归遍历算法-------------------------//Status PreOrderTranRecursion(BiTree T, Status(*Visit)(TElemType e)){ /*---------------先序遍历二叉树的递归算法-------------------*/ // 采用二叉链表存储结构，Visit是对数据元素操作应用的函数 // 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层 if (T) { // T所指节点非空 if (Visit(T-&gt;data)) { // 调用操作函数，Visit采用函数指针，指向操作函数 if (PreOrderTranRecursion(T-&gt;lchild, Visit)) { // 递归调用：Visit所指函数也进行递归 if (PreOrderTranRecursion(T-&gt;rchild, Visit)) return true; } } return false; } else return true;}Status InOrderTranRecursion(BiTree T, Status(*Visit)(TElemType e)){ /*---------------中序遍历二叉树的递归算法-------------------*/ // 采用二叉链表存储结构，Visit是对数据元素操作应用的函数 // 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层 if (T) { // T所指节点非空 if (InOrderTranRecursion(T-&gt;lchild, Visit)) { // 调用操作函数，Visit采用函数指针，指向操作函数 if (Visit(T-&gt;data)) { // 递归调用：Visit所指函数也进行递归 if (InOrderTranRecursion(T-&gt;rchild, Visit)) return true; } } return false; } else return true;}Status PostOrderTranRecursion(BiTree T, Status(*Visit)(TElemType e)){ /*---------------后序遍历二叉树的递归算法-------------------*/ // 采用二叉链表存储结构，Visit是对数据元素操作应用的函数 // 对于一个节点而言，一旦判断节点的三个单元为空即可返回递归上层 if (T) { // T所指节点非空 if (PostOrderTranRecursion(T-&gt;lchild, Visit)) { // 调用操作函数，Visit采用函数指针，指向操作函数 if (PostOrderTranRecursion(T-&gt;rchild, Visit)) { // 递归调用：Visit所指函数也进行递归 if (Visit(T-&gt;data)) return true; } } return false; } else return true;}//--------------------递归遍历算法-------------------------// 非递归算法对于递归算法而言，当数据量比较大时，程序的时间复杂度往往较高，不易于直接使用；一个好的处理方式是，将递归函数转换为循环结构进行求解，而通过栈来模拟递归机理；这里给出一个自定义栈模板类的程序，作为非递归算法的数据存储结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdlib&gt;//-----------------------自定义栈模板类--------------typedef bool Status;// 抽象数据类型定义template&lt;class TElemType&gt;struct SqNode{ TElemType data; struct SqNode *next, *pre; // 基于双向链表模拟栈};template&lt;class TElemType&gt;class mystack{ public: struct SqNode&lt;TElemType&gt; *base,*top; // 栈底和栈顶指针 Status Init() { if(!(base = (struct SqNode&lt;TElemType&gt;*)malloc(sizeof(struct SqNode&lt;TElemType&gt;)))) return false; top = base; // 判断栈空标志 base-&gt;data = 0; // 栈顶结点数据域记录栈中元素数 base-&gt;next = NULL; base-&gt;pre = NULL; return true; } Status Push(TElemType e) { struct SqNode&lt;TElemType&gt; *stemp; if(!(stemp=(struct SqNode&lt;TElemType&gt;*)malloc(sizeof(struct SqNode&lt;TElemType&gt;)))) return false; top-&gt;next = stemp; stemp-&gt;data = e; stemp-&gt;pre = top; stemp-&gt;next = NULL; top = top-&gt;next; // 移动top指针始终位于栈顶 base-&gt;data++; // 栈元素计数 return true; } Status Pop(TElemType &amp;e) { if(top == base) return false; // 栈空 struct SqNode&lt;TElemType&gt; *stemp = top; top = top-&gt;pre; top-&gt;next = NULL; e = stemp-&gt;data; free(stemp); base-&gt;data--; return true; } Status Top(TElemType &amp;p) { if(top == base) return false; p = top-&gt;data; return true; } Status Empty() { if(top == base) return true; else return false; } int Size() { return base-&gt;data; }}; 有了遍历所依赖的数据栈结构，那么便可以通过模拟递归的机理来进行处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//--------------------非递归遍历算法-------------------------////---------------------先序遍历二叉树------------------------//Status PreOrderTranverse_1(BiTree T, Status(*Visit)(TElemType e)){ // 先序遍历二叉树T的非递归算法一 mystack&lt;BiTree&gt; S; S.Init(); //创建并初始化遍历二叉链表所需要的栈 S.Push(T); // 根指针进栈 BiTree p; // 创建二叉树游标指针 while (!S.Empty()) { while (S.Top(p) &amp;&amp; p) { if (!Visit(p-&gt;data)) return false; S.Push(p-&gt;lchild); } S.Pop(p); // 将向左尽头的空指针弹出 if (!S.Empty()) { S.Pop(p); // 根节点出栈 S.Push(p-&gt;rchild); // 遍历后转向 } } return true;}Status PreOrderTranverse_2(BiTree T, Status(*Visit)(TElemType e)){ // 先序遍历二叉树T非递归算法二 mystack&lt;BiTree&gt; S; S.Init(); //创建遍历二叉链表所需要的栈 BiTree p = T; while (p || !S.Empty()) { if (p) { if (!Visit(p-&gt;data)) return false; S.Push(p); // 根指针进栈 p = p-&gt;lchild; // 遍历左子树,当p=NULL时未进栈 } else { S.Pop(p); p = p-&gt;rchild; } } return true;}//---------------------中序遍历二叉树------------------------//Status InOrderTranverse_1(BiTree T, Status(*Visit)(TElemType e)){ // 中序遍历二叉树T的非递归算法一 mystack&lt;BiTree&gt; S; S.Init(); //创建并初始化遍历二叉链表所需要的栈 S.Push(T); // 根指针进栈 BiTree p; // 创建二叉树游标指针 while (!S.Empty()) { while (S.Top(p) &amp;&amp; p) S.Push(p-&gt;lchild); // 向左走到尽头 S.Pop(p); // 将向左尽头的空指针弹出 if (!S.Empty()) { S.Pop(p); // 根节点出栈 if (!Visit(p-&gt;data)) return false; //遍历 S.Push(p-&gt;rchild); // 遍历后转向 } } return true;}Status InOrderTranverse_2(BiTree T, Status(*Visit)(TElemType e)){ // 中序遍历二叉树T非递归算法二 mystack&lt;BiTree&gt; S; S.Init(); //创建遍历二叉链表所需要的栈 BiTree p = T; while (p || !S.Empty()) { if (p) { S.Push(p); // 根指针进栈 p = p-&gt;lchild; // 遍历左子树 } else { S.Pop(p); if (!Visit(p-&gt;data)) return false; p = p-&gt;rchild; } } return true;}//---------------------后序遍历二叉树------------------------//Status PostOrderTranverse_1(BiTree T, Status(*Visit)(TElemType e)){ // 后序遍历二叉树T的非递归算法一 mystack&lt;BiTree&gt; S; S.Init(); //创建并初始化遍历二叉链表所需要的栈 S.Push(T); // 根指针进栈 BiTree p,lastp = NULL; // 创建二叉树游标指针 while (!S.Empty()) { while (S.Top(p) &amp;&amp; p) S.Push(p-&gt;lchild); // 向左走到尽头 S.Pop(p); // 将向左尽头的空指针弹出 if (!S.Empty()) { S.Top(p); // 获取根节点 if (p-&gt;rchild == NULL||p-&gt;rchild == lastp) { // 节点信息无用时直接出栈 S.Pop(p); // 此时结点才可出栈 lastp = p; if (!Visit(p-&gt;data)) return false; //遍历 S.Push(NULL); //保证返回上层结点而不是下一轮继续向左走 }else S.Push(p-&gt;rchild); } } return true;}Status PostOrderTranverse_2(BiTree T, Status(*Visit)(TElemType e)){ // 后序遍历二叉树T非递归算法二 mystack&lt;BiTree&gt; S; S.Init(); //创建遍历二叉链表所需要的栈 BiTree p = T,lastp = NULL; while (p || !S.Empty()) { if (p) { S.Push(p); // 根指针进栈 p = p-&gt;lchild; // 遍历左子树,当p=NULL时未进栈 } else { S.Top(p); if (p-&gt;rchild == NULL || p-&gt;rchild == lastp) { S.Pop(p); if (!Visit(p-&gt;data)) return false; lastp = p; p = NULL; // 往回溯，置于NULL } else p = p-&gt;rchild; // 控制右移转向 } } return true;} 主函数设定为了直观的观察遍历结果，主函数设定一些输出参数： 1234567891011121314151617181920212223242526272829303132int main(){ BiTree T; // 构造一棵二叉树 cout &lt;&lt; &quot;Input binary tree elements in order: (note: '.' means empty tree)\\n&quot;; if (!CreateBiTree(T)) { cout &lt;&lt; &quot;Space allocate error!\\n&quot;; return 0; } cout &lt;&lt; &quot;------------------Binary Recursion Traverse----------------------\\n&quot;; cout &lt;&lt; &quot;Binary Tree First Order Traverse:\\n&quot;; PreOrderTranRecursion(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree Middle Order Traverse:\\n&quot;; InOrderTranRecursion(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree Post Order Traverse:\\n&quot;; PostOrderTranRecursion(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;------------------Binary NonRecursion Traverse-------------------\\n&quot;; cout &lt;&lt; &quot;Binary Tree First Order Traverse 1:\\n&quot;; PreOrderTranverse_1(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree First Order Traverse 2:\\n&quot;; PreOrderTranverse_2(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree Middle Order Traverse 1:\\n&quot;; InOrderTranverse_1(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree Middle Order Traverse 2:\\n&quot;; InOrderTranverse_2(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree Post Order Traverse 1:\\n&quot;; PostOrderTranverse_1(T, TreeTransOperator); cout &lt;&lt; endl &lt;&lt; &quot;Binary Tree Post Order Traverse 2:\\n&quot;; PostOrderTranverse_2(T, TreeTransOperator); cout &lt;&lt; endl; return 0;} 给出一个算例演示： 12345678910111213141516171819202122232425/*One Example:Input binary tree elements in order: (note: '.' means empty tree)A B C . . D E . G . . F . . .------------------Binary Recursion Traverse----------------------Binary Tree First Order Traverse:A B C D E G FBinary Tree Middle Order Traverse:C B E G D F ABinary Tree Post Order Traverse:C G E F D B A------------------Binary NonRecursion Traverse-------------------Binary Tree First Order Traverse 1:A B C D E G FBinary Tree First Order Traverse 2:A B C D E G FBinary Tree Middle Order Traverse 1:C B E G D F ABinary Tree Middle Order Traverse 2:C B E G D F ABinary Tree Post Order Traverse 1:C G E F D B ABinary Tree Post Order Traverse 2:C G E F D B A*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"十字链表","text":"稀疏矩阵的十字链表表示本文对矩阵采用链式存储结构实现三元组的线性表，整个存储结构称作十字链表，并基于此数据结构实现矩阵运算 A+B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;//-----------稀疏矩阵的十字链表表示法-----// 抽象数据类型定义typedef int ElemType;typedef bool Status;// 非零元结点结构typedef struct OLNode { int i, j; // 非零元的行列下标 ElemType value; struct OLNode* right, * down; // 非零元所在的行表和列表的后继元}OLNode, * OLink;// 十字链表结构typedef struct { OLink* rhead, * chead; // row_head and column_head 头节点指针向量 int cols, rows, nums;}CrossList;Status CreateCrossList(CrossList&amp; M);Status CrossListPrint(CrossList M);Status MatrixAdd(CrossList&amp; A, CrossList B);Status DestroyCrossList(CrossList B);int main(){ CrossList A, B; if (!CreateCrossList(A) || !CreateCrossList(B)) { cout &lt;&lt; &quot;Space allocate error!\\n&quot;; return 0; } cout &lt;&lt; &quot;After addiction:\\n&quot;; MatrixAdd(A, B); DestroyCrossList(B); CrossListPrint(A); return 0;}Status CreateCrossList(CrossList&amp; M){ cout &lt;&lt; &quot;Input Matrix rows, cols and nums:\\n&quot;; cin &gt;&gt; M.rows &gt;&gt; M.cols &gt;&gt; M.nums; cout &lt;&lt; &quot;Input Matrix elements:(x, y, value)\\n&quot;; // 为行表和列表指针申请空间，注意rhead,chead为指向指针的指针 if (!(M.rhead = (OLink*)malloc(M.rows * sizeof(OLink)))) return false; if (!(M.chead = (OLink*)malloc(M.cols * sizeof(OLink)))) return false; // 初始化行列头指针向量 for (int i = 0; i &lt; M.rows; i++) M.rhead[i] = NULL; for (int i = 0; i &lt; M.cols; i++) M.chead[i] = NULL; int temp_i, temp_j, temp_value; for (cin &gt;&gt; temp_i &gt;&gt; temp_j &gt;&gt; temp_value; temp_i != 0; cin &gt;&gt; temp_i &gt;&gt; temp_j &gt;&gt; temp_value) { // 假定输入以“0 0 0”结束 OLink p; if (!(p = (OLink)malloc(sizeof(OLNode)))) return false; // 生成结点 p-&gt;i = temp_i; p-&gt;j = temp_j; p-&gt;value = temp_value; /*-----------处理行插入情况------------*/ if (M.rhead[temp_i - 1] == NULL || M.rhead[temp_i - 1]-&gt;j &gt; temp_j) { // 判断是否在首节点插入 p-&gt;right = M.rhead[temp_i - 1]; // 这个地方一定保证了下面搜寻情况时最后一个结点的right域始终是NULL M.rhead[temp_i - 1] = p; } else { // 否则需要遍历在行表中的插入位置 // 最先就比较当前行的第二个元素q-&gt;right，这种情况无法探查首结点，也是为何需要特判首结点 // 试探性的比较主要由单向链表结构决定的，只能巡查next，不能回溯 OLink q = NULL; for (q = M.rhead[temp_i - 1]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j &lt; temp_j; q = q-&gt;right); // 最终停在待插入节点位置的前一个位置上 p-&gt;right = q-&gt;right; q-&gt;right = p; } /*-----------处理列插入情况------------*/ // 列插入情况与行插入类似 if (M.chead[temp_j - 1] == NULL || M.chead[temp_j - 1]-&gt;i &gt; temp_i) { p-&gt;down = M.chead[temp_j - 1]; M.chead[temp_j - 1] = p; } else { OLink q = NULL; for (q = M.chead[temp_j - 1]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i &lt; temp_i; q = q-&gt;down); p-&gt;down = q-&gt;down; q-&gt;down = p; } } return true;}Status MatrixAdd(CrossList &amp;A, CrossList B){ // 实现十字链表表示的矩阵加法 // 判断矩阵同型 if (A.rows != B.rows || A.cols != B.cols) return false; // 构造矩阵A每一列的游标 OLink colptr[100]; for (int i = 0; i &lt; A.cols; i++) colptr[i] = A.chead[i]; for (int k = 0; k &lt; A.rows; k++) { // pre指向矩阵A中pa前一节点 OLink pa = A.rhead[k], pb = B.rhead[k], pre = NULL; while (pb) { // 处理B矩阵每一行元素 // A+B情况分类处理 // &lt;1&gt; 直接复制B结点到A矩阵中(可以直接移动但考虑最后释放B矩阵的开销，不如直接复制再释放) if (pa == NULL || pa-&gt;j &gt; pb-&gt;j) { // 复制结点 OLink p = (OLink)malloc(sizeof(OLNode)); if (!p) return false; p-&gt;i = pb-&gt;i; p-&gt;j = pb-&gt;j; p-&gt;value = pb-&gt;value; //新节点值域更新 // 行表更改——归属于哪一行 if (pre == NULL) A.rhead[pb-&gt;i - 1] = p; else pre-&gt;right = p; p-&gt;right = pa; // 新节点right域更新 pre = p; //列表更改——归属于哪一列 if (!A.chead[p-&gt;j - 1] || A.chead[p-&gt;j - 1]-&gt;i &gt; p-&gt;i) { p-&gt;down = A.chead[p-&gt;j - 1]; //新节点down域更新 A.chead[p-&gt;j - 1] = p; } else { p-&gt;down = colptr[p-&gt;j - 1]-&gt;down; colptr[p-&gt;j - 1]-&gt;down = p; } colptr[p-&gt;j - 1] = p; pb = pb-&gt;right; } else if (pa != NULL &amp;&amp; pa-&gt;j &lt; pb-&gt;j) { // &lt;2&gt; A矩阵同行元素位置在前时直接指针后移 pre = pa; pa = pa-&gt;right; } else if (pa-&gt;j == pb-&gt;j) { // &lt;3&gt; 执行加法运算 pa-&gt;value += pb-&gt;value; if (pa-&gt;value == 0) { // 特判和为零时从矩阵A中删除节点 // 行表 if (pre == NULL) A.rhead[pa-&gt;i - 1] = pa-&gt;right; else pre-&gt;right = pa-&gt;right; OLink p = pa; pa = pa-&gt;right; // 后移继续下一运算 // 列表 if (A.chead[p-&gt;j - 1] == p) A.chead[p-&gt;j - 1] = colptr[p-&gt;j - 1] = p-&gt;down; else colptr[p-&gt;j - 1]-&gt;down = p-&gt;down; free(p); } pb = pb-&gt;right; } } for (int i = 0; i &lt; A.cols; i++) if (colptr[i] &amp;&amp; colptr[i]-&gt;down &amp;&amp; colptr[i]-&gt;down-&gt;j &lt; k + 2) colptr[i] = colptr[i]-&gt;down; } return true;}Status CrossListPrint(CrossList M){ cout &lt;&lt; &quot;Output Matrix:\\n&quot;; for (int i = 0; i &lt; M.rows; i++) { for (int j = 0; j &lt; M.cols; j++) { if (M.rhead[i] &amp;&amp; M.rhead[i]-&gt;j == (j + 1)) { cout &lt;&lt; M.rhead[i]-&gt;value &lt;&lt; &quot; &quot;; M.rhead[i] = M.rhead[i]-&gt;right; } else cout &lt;&lt; &quot;0 &quot;; } cout &lt;&lt; &quot;\\n&quot;; } return true;}Status DestroyCrossList(CrossList B){ for (int i = 0; i &lt; B.rows; i++) { OLink p = B.rhead[i]; while (p) { OLink q = p; p = p-&gt;right; free(q); } } free(B.rhead); free(B.chead); return true;} 给出一个具体实现算例： 123456789101112131415161718192021222324/*------One Example:Input Matrix rows, cols and nums:4 3 12Input Matrix elements:(x, y, value)1 1 -11 3 22 3 -13 1 20 0 0 // End_Input_SignInput Matrix rows, cols and nums:4 3 12Input Matrix elements:(x, y, value)2 1 32 3 13 2 44 1 20 0 0 // End_Input_SignAfter addiction:Output Matrix:-1 0 23 0 02 4 02 0 0*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/"},{"title":"图的存储结构","text":"一、图的邻接矩阵表示——（Adjacency Matrix)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;limits.h&gt;using namespace std;//----------------自定义邻接矩阵模板类-----------------////-------------图的数组（邻接矩阵存储）表示-----------//#define Max_Vertex_Num 20 #define inp(i,x,y) for(i=x;i&lt;=y;i++)#define dep(i,x,y) for(i=x;i&gt;=y;i--)#define INFINITY INT_MAXtypedef enum { DG, DN, UDG, UDN }GraphKind; //{有向图，有向网，无向图，无向网}typedef int VRType;typedef string InfoType;typedef string VertexType;typedef bool Status;typedef struct ArcCell { VRType adj; // 顶点关系类型，无权图，用1或0表相邻否；有权图为权值 InfoType info; //弧相关信息指针}ArcCell, AdjMatrix[Max_Vertex_Num][Max_Vertex_Num];typedef struct { VertexType vexs[Max_Vertex_Num]; // 顶点向量 AdjMatrix arcs; // 邻接矩阵 int vexnum, arcnum; // 图的当前顶点数和弧数 GraphKind kind; // 图种类标志 }MGraph;int LocateVex(MGraph G, VertexType v);Status CreateDG(MGraph&amp; G);Status CreateDN(MGraph&amp; G);Status CreateUDG(MGraph&amp; G);Status CreateUDN(MGraph&amp; G);Status CreateGraph(MGraph&amp; G);Status GraphPrint(MGraph G);int main(){ MGraph G; CreateGraph(G); GraphPrint(G); return 0;}Status CreateGraph(MGraph&amp; G){ // 采用邻接矩阵表示法，构造图G int sign = 0; cout &lt;&lt; &quot;Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):\\n&quot;; cin &gt;&gt; sign; switch (sign) { case DG: G.kind = DG; return CreateDG(G); // diagraph case DN: G.kind = DN; return CreateDN(G); // dianetwork case UDG: G.kind = UDG; return CreateUDG(G); //undiagraph case UDN: G.kind = UDN; return CreateUDN(G); //undianetwork default:return false; }}Status CreateUDN(MGraph&amp; G){ // 采用数组（邻接矩阵）表示法构造无向网G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.vexs[i]; // 节点数据 inp(i, 0, G.vexnum - 1) // 初始化邻接矩阵 inp(j, 0, G.vexnum - 1) G.arcs[i][j] = { INFINITY, &quot;&quot; }; //{adj,info} cout &lt;&lt; &quot;Input two vertices and weight of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点和权值 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; G.arcs[p1][p2].adj = w; // 弧&lt;v1,v2&gt;的权值w if (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info; // 如果弧有信息则输入 G.arcs[p2][p1] = G.arcs[p1][p2]; // 无向图 } return true;}Status CreateUDG(MGraph&amp; G){ // 采用数组（邻接矩阵）表示法构造无向图G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.vexs[i]; // 节点数据 inp(i, 0, G.vexnum - 1) // 初始化邻接矩阵 inp(j, 0, G.vexnum - 1) G.arcs[i][j] = { 0, &quot;&quot; }; //{adj,info} cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; G.arcs[p1][p2].adj = 1; // 弧&lt;v1,v2&gt;的权值w if (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info; // 如果弧有信息则输入 G.arcs[p2][p1] = G.arcs[p1][p2]; // 无向图 } return true;}Status CreateDG(MGraph&amp; G){ // 采用数组（邻接矩阵）表示法构造无向图G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.vexs[i]; // 节点数据 inp(i, 0, G.vexnum - 1) // 初始化邻接矩阵 inp(j, 0, G.vexnum - 1) G.arcs[i][j] = { 0, &quot;&quot; }; //{adj,info} cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; G.arcs[p1][p2].adj = 1; // 弧&lt;v1,v2&gt;的权值w if (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info; // 如果弧有信息则输入 } return true;}Status CreateDN(MGraph&amp; G){ // 采用数组（邻接矩阵）表示法构造无向图G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.vexs[i]; // 节点数据 inp(i, 0, G.vexnum - 1) // 初始化邻接矩阵 inp(j, 0, G.vexnum - 1) G.arcs[i][j] = { INFINITY, &quot;&quot; }; //{adj,info} cout &lt;&lt; &quot;Input two vertices and weight of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点和权值 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; G.arcs[p1][p2].adj = w; // 弧&lt;v1,v2&gt;的权值w if (IncInfo) cin &gt;&gt; G.arcs[p1][p2].info; // 如果弧有信息则输入 } return true;}int LocateVex(MGraph G, VertexType v){ int i = 0; inp(i, 0, G.vexnum - 1) { if (G.vexs[i] == v) return i; } return -1;}Status GraphPrint(MGraph G){ cout &lt;&lt; &quot;Output Graph Information:\\n&quot;; cout &lt;&lt; &quot;Graph Kind: &quot;; switch (G.kind) { case DG:cout &lt;&lt; &quot;directed graph\\n&quot;; // diagraph break; case DN:cout &lt;&lt; &quot;directed nets\\n&quot;; // dianetwork break; case UDG:cout &lt;&lt; &quot;undirected graph\\n&quot;; //undiagraph break; case UDN:cout &lt;&lt; &quot;undirected nets\\n&quot;; //undianetwork break; default:return false; } cout &lt;&lt; &quot;Vextices number: &quot; &lt;&lt; G.vexnum &lt;&lt; &quot; &quot; &lt;&lt; &quot;Arcs number: &quot; &lt;&lt; G.arcnum &lt;&lt; endl; int i = 0, j = 0; cout &lt;&lt; &quot;Vextices Vector Information:\\n&quot;; int sign = (G.kind == DG || G.kind == UDG) ? 1 : 0; // 图标记 inp(i, 0, G.vexnum - 1) { int Outdegree = 0, Indegree = 0; inp(j, 0, G.vexnum - 1) { if (G.arcs[i][j].adj != INFINITY &amp;&amp; (!sign || (sign &amp;&amp; G.arcs[i][j].adj != 0))) { Outdegree++; cout &lt;&lt; G.vexs[i] &lt;&lt; &quot;-&lt;&quot; &lt;&lt; G.arcs[i][j].adj &lt;&lt; &quot;&gt;-&quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; &quot;; } if (G.arcs[j][i].adj != INFINITY &amp;&amp; (!sign || (sign &amp;&amp; G.arcs[j][i].adj != 0))) Indegree++; } cout &lt;&lt; endl &lt;&lt; G.vexs[i]; if (G.kind == DG || G.kind == DN) cout &lt;&lt; &quot; Vextice Degree: &quot; &lt;&lt; Outdegree + Indegree &lt;&lt; &quot; Outdegree: &quot; &lt;&lt; Outdegree &lt;&lt; &quot; Indegree: &quot; &lt;&lt; Indegree &lt;&lt; endl; else cout &lt;&lt; &quot; Vextice Degree: &quot; &lt;&lt; Outdegree &lt;&lt; endl; } return true;} 给出一个算例演示： 1234567891011121314151617181920212223242526272829303132333435/*-------------Here is a demo------------Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):1Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):6 10 0Input Graph Node Sign:v1 v2 v3 v4 v5 v6Input two vertices and weight of the edges:v1 v2 5v1 v4 7v2 v3 4v3 v1 8v3 v6 9v4 v3 5v4 v6 6v5 v4 5v6 v1 3v6 v5 1Output Graph Information:Graph Kind: directed netsVextices number: 6 Arcs number: 10Vextices Vector Information:v1-&lt;5&gt;-v2 v1-&lt;7&gt;-v4v1 Vextice Degree: 4 Outdegree: 2 Indegree: 2v2-&lt;4&gt;-v3v2 Vextice Degree: 2 Outdegree: 1 Indegree: 1v3-&lt;8&gt;-v1 v3-&lt;9&gt;-v6v3 Vextice Degree: 4 Outdegree: 2 Indegree: 2v4-&lt;5&gt;-v3 v4-&lt;6&gt;-v6v4 Vextice Degree: 4 Outdegree: 2 Indegree: 2v5-&lt;5&gt;-v4v5 Vextice Degree: 2 Outdegree: 1 Indegree: 1v6-&lt;3&gt;-v1 v6-&lt;1&gt;-v5v6 Vextice Degree: 4 Outdegree: 2 Indegree: 2*/ 二、图的邻接表表示——（Adjacency List)本节基于邻接表和逆邻接表表示图，以及求解图的度数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;//---------------------图的邻接表存储表示-----------------//#define inp(i,x,y) for(i=x;i&lt;=y;i++)#define dep(i,x,y) for(i=x;i&gt;=y;i--)#define Max_Vertex_Num 20typedef enum { DG, DN, UDG, UDN }GraphKind; //{有向图，有向网，无向图，无向网}typedef string InfoType;typedef string VertexType;typedef bool Status;//----------弧节点结构-------------//typedef struct ArcNode { int adjvex; // 该弧所指向的顶点位置 int weight; // 弧的权值 struct ArcNode* nextarc; // 指向下一条弧指针 InfoType info; // 该弧相关信息 ArcNode() { adjvex = weight = 0; nextarc = NULL; info = &quot;&quot;; }}ArcNode;//----------头节点结构---------------//typedef struct VNode { VertexType data; // 顶点信息 int Outdegree; // 节点对应的出度 ArcNode* firstarc; // 指向第一条依附该顶点的弧的指针 VNode() { data = &quot;&quot;; Outdegree = 0; firstarc = NULL; }}VNode, AdjList[Max_Vertex_Num];//----------图结构定义---------------//typedef struct { AdjList Vextices; int vexnum, arcnum; // 图的顶点数和弧数 int kind; // 图的种类标志}ALGraph;//--------------头节点定位函数---------------------//int LocateVex(ALGraph G, VertexType v);//-------------------构建节点函数------------------//Status GraphAddNode(ALGraph&amp; G, int p1, int p2, int w, int IncInfo);//-------------------图创建函数--------------------//Status CreateDG(ALGraph&amp; G, ALGraph&amp; GR);Status CreateDN(ALGraph&amp; G, ALGraph&amp; GR);Status CreateUDG(ALGraph&amp; G, ALGraph&amp; GR);Status CreateUDN(ALGraph&amp; G, ALGraph&amp; GR);Status CreateGraph(ALGraph&amp; G, ALGraph&amp; GR);//------------------图输出函数---------------------//Status GraphPrint(ALGraph G, ALGraph GR);int main(){ ALGraph G, GR; // G:邻接表，GR:逆邻接表 CreateGraph(G, GR); GraphPrint(G, GR); return 0;}Status CreateGraph(ALGraph&amp; G, ALGraph&amp; GR){ cout &lt;&lt; &quot;Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):\\n&quot;; cin &gt;&gt; G.kind; // 种类标识 GR.kind = G.kind; switch (G.kind) { case 0:return CreateDG(G, GR); case 1:return CreateDN(G, GR); case 2:return CreateUDG(G, GR); case 3:return CreateUDN(G, GR); default:return false; }}Status CreateDG(ALGraph&amp; G, ALGraph&amp; GR){ // 采用邻接表表示法构造有向图G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 GR.vexnum = G.vexnum; GR.arcnum = G.arcnum; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) { cin &gt;&gt; G.Vextices[i].data; // 节点数据 GR.Vextices[i].data = G.Vextices[i].data; } cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, 1, IncInfo); // 邻接表中p1-&gt;p2 ==&gt; p1的出度 GraphAddNode(GR, p2, p1, 1, IncInfo); // 逆邻接表中p1-&gt;p2 ==&gt; p2的入度 } return true;}Status CreateDN(ALGraph&amp; G, ALGraph&amp; GR){ // 采用邻接表表示法构造有向网G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 GR.vexnum = G.vexnum; GR.arcnum = G.arcnum; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) { cin &gt;&gt; G.Vextices[i].data; // 节点数据 GR.Vextices[i].data = G.Vextices[i].data; } cout &lt;&lt; &quot;Input two vertices and weight of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, w, IncInfo); // 邻接表中p1-&gt;p2 ==&gt; p1的出度 GraphAddNode(GR, p2, p1, w, IncInfo); // 逆邻接表中p1-&gt;p2 ==&gt; p2的入度 } return true;}Status CreateUDG(ALGraph&amp; G, ALGraph&amp; GR){ // 采用邻接表表示法构造无向图G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 GR.vexnum = G.vexnum; GR.arcnum = G.arcnum; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) { cin &gt;&gt; G.Vextices[i].data; // 节点数据 GR.Vextices[i].data = G.Vextices[i].data; } cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; // 对无向图而言，逆邻接表作用不是很显著，实际使用中可删除 GraphAddNode(G, p1, p2, 1, IncInfo); // p2挂在p1链表上 GraphAddNode(G, p2, p1, 1, IncInfo); // p1挂在p2链表上 GraphAddNode(GR, p1, p2, 1, IncInfo); GraphAddNode(GR, p2, p1, 1, IncInfo); } return true;}Status CreateUDN(ALGraph&amp; G, ALGraph&amp; GR){ // 采用邻接表表示法构造无向网G int IncInfo = 0, i = 0, j = 0; cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; IncInfo; // IncInfo为0则各弧不含其他信息 GR.vexnum = G.vexnum; GR.arcnum = G.arcnum; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) { cin &gt;&gt; G.Vextices[i].data; // 节点数据 GR.Vextices[i].data = G.Vextices[i].data; } cout &lt;&lt; &quot;Input two vertices and weight of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, w, IncInfo); // 附权值w GraphAddNode(G, p2, p1, w, IncInfo); GraphAddNode(GR, p1, p2, w, IncInfo); GraphAddNode(GR, p2, p1, w, IncInfo); } return true;}Status GraphAddNode(ALGraph&amp; G, int p1, int p2, int w, int IncInfo){ // 将弧的头节点p2挂在尾节点p1的链表上 ArcNode* p = G.Vextices[p1].firstarc; int sign = 0; while (p) { if (p-&gt;adjvex == p2) { //如果已经存在 sign = 1; if (IncInfo) cin &gt;&gt; p-&gt;info; // 如果弧有信息则输入 break; } if (!p-&gt;nextarc) break; p = p-&gt;nextarc; } if (!sign) { if (!p) { p = (ArcNode*)malloc(sizeof(ArcNode)); G.Vextices[p1].firstarc = p; } else { p-&gt;nextarc = (ArcNode*)malloc(sizeof(ArcNode)); p = p-&gt;nextarc; } p-&gt;adjvex = p2; p-&gt;weight = w; // 弧&lt;v1,v2&gt;的权值w p-&gt;nextarc = NULL; if (IncInfo) cin &gt;&gt; p-&gt;info; // 如果弧有信息则输入 G.Vextices[p1].Outdegree++; } return true;}int LocateVex(ALGraph G, VertexType v){ int i = 0; inp(i, 0, G.vexnum - 1) { if (G.Vextices[i].data == v) return i; } return -1;}Status GraphPrint(ALGraph G, ALGraph GR){ cout &lt;&lt; &quot;----------------Output Graph Information-----------------\\n&quot;; cout &lt;&lt; &quot;Graph Kind: &quot;; switch (G.kind) { case DG:cout &lt;&lt; &quot;directed graph\\n&quot;; // diagraph break; case DN:cout &lt;&lt; &quot;directed nets\\n&quot;; // dianetwork break; case UDG:cout &lt;&lt; &quot;undirected graph\\n&quot;; //undiagraph break; case UDN:cout &lt;&lt; &quot;undirected nets\\n&quot;; //undianetwork break; default:return false; } cout &lt;&lt; &quot;Vextices number: &quot; &lt;&lt; G.vexnum &lt;&lt; &quot; &quot; &lt;&lt; &quot;Arcs number: &quot; &lt;&lt; G.arcnum &lt;&lt; endl; int i = 0, j = 0; cout &lt;&lt; endl &lt;&lt; &quot;----------------Vextices Vector Information----------------\\n&quot;; int sign = (G.kind == DG || G.kind == DN) ? 1 : 0; // 图标记 cout &lt;&lt; &quot;The Nodes Path:\\n&quot;; inp(i, 0, G.vexnum - 1) { ArcNode* p = G.Vextices[i].firstarc; ArcNode* q = GR.Vextices[i].firstarc; if (sign) { cout &lt;&lt; &quot;Out path: &quot;; while (p) { cout &lt;&lt; G.Vextices[i].data &lt;&lt; &quot;-[&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;]-&gt;&quot; &lt;&lt; G.Vextices[p-&gt;adjvex].data &lt;&lt; &quot; &quot;; p = p-&gt;nextarc; } cout &lt;&lt; endl &lt;&lt; &quot;In path: &quot;; while (q) { cout &lt;&lt; GR.Vextices[q-&gt;adjvex].data &lt;&lt; &quot;-[&quot; &lt;&lt; q-&gt;weight &lt;&lt; &quot;]-&gt;-&quot; &lt;&lt; GR.Vextices[i].data &lt;&lt; &quot; &quot;; q = q-&gt;nextarc; } cout &lt;&lt; endl &lt;&lt; G.Vextices[i].data; cout &lt;&lt; &quot; Vextice Degree: &quot; &lt;&lt; G.Vextices[i].Outdegree + GR.Vextices[i].Outdegree &lt;&lt; &quot; Outdegree: &quot; &lt;&lt; G.Vextices[i].Outdegree &lt;&lt; &quot; Indegree: &quot; &lt;&lt; GR.Vextices[i].Outdegree &lt;&lt; endl; } else { cout &lt;&lt; &quot;Out path: &quot;; while (p) { cout &lt;&lt; G.Vextices[i].data &lt;&lt; &quot;-&lt;-[&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;]-&gt;-&quot; &lt;&lt; G.Vextices[p-&gt;adjvex].data &lt;&lt; &quot; &quot;; p = p-&gt;nextarc; } cout &lt;&lt; endl &lt;&lt; G.Vextices[i].data; cout &lt;&lt; &quot; Vextice Degree: &quot; &lt;&lt; G.Vextices[i].Outdegree &lt;&lt; endl; } cout &lt;&lt; endl; } return true;} 给出一个算例演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//---------- Here is a drected graph demo -------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):0Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):4 7 0Input Graph Node Sign:V1 V2 V3 V4Input two vertices of the edges:V1 V2V3 V1V1 V3V4 V1V3 V4V4 V3V4 V2----------------Output Graph Information-----------------Graph Kind: directed graphVextices number: 4 Arcs number: 7----------------Vextices Vector Information----------------The Nodes Path:Out path: V1-[1]-&gt;V2 V1-[1]-&gt;V3In path: V3-[1]-&gt;-V1 V4-[1]-&gt;-V1V1 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path:In path: V1-[1]-&gt;-V2 V4-[1]-&gt;-V2V2 Vextice Degree: 2 Outdegree: 0 Indegree: 2Out path: V3-[1]-&gt;V1 V3-[1]-&gt;V4In path: V1-[1]-&gt;-V3 V4-[1]-&gt;-V3V3 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: V4-[1]-&gt;V1 V4-[1]-&gt;V3 V4-[1]-&gt;V2In path: V3-[1]-&gt;-V4V4 Vextice Degree: 4 Outdegree: 3 Indegree: 1*///---------- Here is a undrected graph demo -------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):2Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):4 7 0Input Graph Node Sign:V1 V2 V3 V4Input two vertices of the edges:V1 V2V3 V1V1 V3V4 V1V3 V4V4 V3V4 V2----------------Output Graph Information-----------------Graph Kind: undirected graphVextices number: 4 Arcs number: 7----------------Vextices Vector Information----------------The Nodes Path:Out path: V1-&lt;-[1]-&gt;-V2 V1-&lt;-[1]-&gt;-V3 V1-&lt;-[1]-&gt;-V4V1 Vextice Degree: 3Out path: V2-&lt;-[1]-&gt;-V1 V2-&lt;-[1]-&gt;-V4V2 Vextice Degree: 2Out path: V3-&lt;-[1]-&gt;-V1 V3-&lt;-[1]-&gt;-V4V3 Vextice Degree: 2Out path: V4-&lt;-[1]-&gt;-V1 V4-&lt;-[1]-&gt;-V3 V4-&lt;-[1]-&gt;-V2V4 Vextice Degree: 3*/ 三、图的十字链表表示——（Orthogonal List）本节实现对图的十字链表表示（主要用于有向图的存储），其中对无向图/网没有实现判重的功能，即不允许无向图/网先后输入同一条弧； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;//----------------有向图的十字链表存储表示------------------//#define Max_Vertex_Num 20#define MAX_Length_Info 10#define inp(i,x,y) for(i=x;i&lt;=y;i++)#define dep(i,x,y) for(i=x;i&gt;=y;i--)#define InfoType char*#define VertexType string#define Status booltypedef enum { DG, DN, UDG, UDN }GraphKind; //{有向图，有向网，无向图，无向网}//---------------图的弧结构表示------------------//typedef struct ArcBox { int tailvex, headvex, weight; // 该弧的尾和头顶点的位置==&gt;指向顺序存储结构中的编号 struct ArcBox* hlink, * tlink; // 分别为弧头相同和弧尾相同的弧的链域 // 对每一个节点而言，弧头相同的节点和弧尾相同的节点指向两个链表构成十字链表分别表示入度和出度 InfoType info; // 弧信息}ArcBox;//---------------图的顶点结构表示-----------------//typedef struct VexNode { VertexType data; ArcBox* firstin, * firstout; // 分别指向该顶点第一条入弧和出弧 VexNode() { data = &quot;&quot;; firstin = firstout = NULL; }}VexNode, Xlist[Max_Vertex_Num];typedef struct { Xlist Vextices; // 表头向量 int kind, vexnum, arcnum, IncInfo; //图种类表识，节点数和弧数，弧有无信息}OLGraph;int LocateVex(OLGraph G, VertexType v);Status GraphAddNode(OLGraph&amp; G, int p1, int p2, int w);Status CreateDG(OLGraph&amp; G);Status CreateDN(OLGraph&amp; G);Status CreateUDG(OLGraph&amp; G);Status CreateUDN(OLGraph&amp; G);Status CreateGraph(OLGraph&amp; G);Status GraphPrint(OLGraph G);int main(){ OLGraph G; CreateGraph(G); GraphPrint(G); return 0;}Status CreateGraph(OLGraph&amp; G){ cout &lt;&lt; &quot;Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):\\n&quot;; cin &gt;&gt; G.kind; // 种类标识 switch (G.kind) { case DG:return CreateDG(G); case DN:return CreateDN(G); case UDG:return CreateUDG(G); case UDN:return CreateUDN(G); default:return false; }}Status CreateDG(OLGraph&amp; G){ // 采用十字链表存储表示，构造有向图G(G.kind=DG) cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo; int i = 0; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.Vextices[i].data; // 节点顶点值 cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { // 输入各弧并构造十字链表 VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, 1); // p1-&gt;p2 } return true;}Status CreateDN(OLGraph&amp; G){ // 采用十字链表存储表示，构造有向网G(G.kind=DN) cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo; int i = 0; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.Vextices[i].data; // 节点顶点值 cout &lt;&lt; &quot;Input two vertices and weight of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { // 输入各弧并构造十字链表 VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, w); // p1-&gt;p2 } return true;}Status CreateUDG(OLGraph&amp; G){ // 采用十字链表存储表示，构造无向图G(G.kind=UDG) cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo; int i = 0; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.Vextices[i].data; // 节点顶点值 cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { // 输入各弧并构造十字链表 VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, 1); // p1-&gt;p2 GraphAddNode(G, p2, p1, 1); // p2-&gt;p1 } return true;}Status CreateUDN(OLGraph&amp; G){ // 采用十字链表存储表示，构造无向网G(G.kind=UDN) cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo; int i = 0; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.Vextices[i].data; // 节点顶点值 cout &lt;&lt; &quot;Input two vertices and weight of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { // 输入各弧并构造十字链表 VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; GraphAddNode(G, p1, p2, w); // p1-&gt;p2 GraphAddNode(G, p2, p1, w); // p2-&gt;p1 } return true;}Status GraphAddNode(OLGraph&amp; G, int p1, int p2, int w){ ArcBox* p = (ArcBox*)malloc(sizeof(ArcBox)); // 创建弧单元 if (!p) return false; //十字链表——涉及两个链表的交接==&gt;最终first指针会指向最后输入的一组数据 *p = { p1, p2, w, G.Vextices[p2].firstin, G.Vextices[p1].firstout, NULL }; // 对弧节点赋值 G.Vextices[p2].firstin = G.Vextices[p1].firstout = p; // 完成在入弧和出弧链头的插入 if (G.IncInfo) { p-&gt;info = (char*)malloc(MAX_Length_Info*sizeof(char)); cout &lt;&lt; &quot;Input the arc information: &quot;; cin &gt;&gt; p-&gt;info; } return true;}int LocateVex(OLGraph G, VertexType v){ int i = 0; inp(i, 0, G.vexnum - 1) { if (G.Vextices[i].data == v) return i; } return -1;}Status GraphPrint(OLGraph G){ cout &lt;&lt; &quot;----------------Output Graph Information-----------------\\n&quot;; cout &lt;&lt; &quot;Graph Kind: &quot;; switch (G.kind) { case DG:cout &lt;&lt; &quot;directed graph\\n&quot;; // diagraph break; case DN:cout &lt;&lt; &quot;directed nets\\n&quot;; // dianetwork break; case UDG:cout &lt;&lt; &quot;undirected graph\\n&quot;; //undiagraph break; case UDN:cout &lt;&lt; &quot;undirected nets\\n&quot;; //undianetwork break; default:return false; } cout &lt;&lt; &quot;Vextices number: &quot; &lt;&lt; G.vexnum &lt;&lt; &quot; &quot; &lt;&lt; &quot;Arcs number: &quot; &lt;&lt; G.arcnum &lt;&lt; endl; int i = 0, j = 0; cout &lt;&lt; endl &lt;&lt; &quot;----------------Vextices Vector Information----------------\\n&quot;; cout &lt;&lt; &quot;The Nodes Path:\\n&quot;; inp(i, 0, G.vexnum - 1) { ArcBox* p = G.Vextices[i].firstout; ArcBox* q = G.Vextices[i].firstin; int Outdegree = 0, Indegree = 0; cout &lt;&lt; &quot;Out path: &quot;; while (p) { cout &lt;&lt; G.Vextices[p-&gt;tailvex].data &lt;&lt; &quot;-[&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;]-&gt;&quot; &lt;&lt; G.Vextices[p-&gt;headvex].data &lt;&lt; &quot; &quot;; p = p-&gt;tlink; Outdegree++; } cout &lt;&lt; endl &lt;&lt; &quot;In path: &quot;; while (q) { cout &lt;&lt; G.Vextices[q-&gt;tailvex].data &lt;&lt; &quot;-[&quot; &lt;&lt; q-&gt;weight &lt;&lt; &quot;]-&gt;&quot; &lt;&lt; G.Vextices[q-&gt;headvex].data &lt;&lt; &quot; &quot;; q = q-&gt;hlink; Indegree++; } cout &lt;&lt; endl &lt;&lt; G.Vextices[i].data; cout &lt;&lt; &quot; Vextice Degree: &quot; &lt;&lt; Outdegree + Indegree &lt;&lt; &quot; Outdegree: &quot; &lt;&lt; Outdegree &lt;&lt; &quot; Indegree: &quot; &lt;&lt; Indegree &lt;&lt; endl; cout &lt;&lt; endl; } return true;} 给出一个算例演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//---------------Here is a directed graph demo-----------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):0Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):4 7 0Input Graph Node Sign:V1 V2 V3 V4Input two vertices of the edges:V1 V2V3 V1V1 V3V4 V1V3 V4V4 V3V4 V2----------------Output Graph Information-----------------Graph Kind: directed graphVextices number: 4 Arcs number: 7----------------Vextices Vector Information----------------The Nodes Path:Out path: V1-[1]-&gt;V3 V1-[1]-&gt;V2In path: V4-[1]-&gt;V1 V3-[1]-&gt;V1V1 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path:In path: V4-[1]-&gt;V2 V1-[1]-&gt;V2V2 Vextice Degree: 2 Outdegree: 0 Indegree: 2Out path: V3-[1]-&gt;V4 V3-[1]-&gt;V1In path: V4-[1]-&gt;V3 V1-[1]-&gt;V3V3 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: V4-[1]-&gt;V2 V4-[1]-&gt;V3 V4-[1]-&gt;V1In path: V3-[1]-&gt;V4V4 Vextice Degree: 4 Outdegree: 3 Indegree: 1*///-------------------Here is a directed net demo--------------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):1Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):6 10 0Input Graph Node Sign:v1 v2 v3 v4 v5 v6Input two vertices and weight of the edges:v1 v2 5v1 v4 7v2 v3 4v3 v1 8v3 v6 9v4 v3 5v4 v6 6v5 v4 5v6 v1 3v6 v5 1----------------Output Graph Information-----------------Graph Kind: directed netsVextices number: 6 Arcs number: 10----------------Vextices Vector Information----------------The Nodes Path:Out path: v1-[7]-&gt;v4 v1-[5]-&gt;v2In path: v6-[3]-&gt;v1 v3-[8]-&gt;v1v1 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: v2-[4]-&gt;v3In path: v1-[5]-&gt;v2v2 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: v3-[9]-&gt;v6 v3-[8]-&gt;v1In path: v4-[5]-&gt;v3 v2-[4]-&gt;v3v3 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: v4-[6]-&gt;v6 v4-[5]-&gt;v3In path: v5-[5]-&gt;v4 v1-[7]-&gt;v4v4 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: v5-[5]-&gt;v4In path: v6-[1]-&gt;v5v5 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: v6-[1]-&gt;v5 v6-[3]-&gt;v1In path: v4-[6]-&gt;v6 v3-[9]-&gt;v6v6 Vextice Degree: 4 Outdegree: 2 Indegree: 2*///---------------Here is a undirected graph demo-----------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):2Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):7 6 0Input Graph Node Sign:A B C D E F GInput two vertices of the edges:A CA FA DB EG EE D----------------Output Graph Information-----------------Graph Kind: undirected graphVextices number: 7 Arcs number: 6----------------Vextices Vector Information----------------The Nodes Path:Out path: A-[1]-&gt;D A-[1]-&gt;F A-[1]-&gt;CIn path: D-[1]-&gt;A F-[1]-&gt;A C-[1]-&gt;AA Vextice Degree: 6 Outdegree: 3 Indegree: 3Out path: B-[1]-&gt;EIn path: E-[1]-&gt;BB Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: C-[1]-&gt;AIn path: A-[1]-&gt;CC Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: D-[1]-&gt;E D-[1]-&gt;AIn path: E-[1]-&gt;D A-[1]-&gt;DD Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: E-[1]-&gt;D E-[1]-&gt;G E-[1]-&gt;BIn path: D-[1]-&gt;E G-[1]-&gt;E B-[1]-&gt;EE Vextice Degree: 6 Outdegree: 3 Indegree: 3Out path: F-[1]-&gt;AIn path: A-[1]-&gt;FF Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: G-[1]-&gt;EIn path: E-[1]-&gt;GG Vextice Degree: 2 Outdegree: 1 Indegree: 1*/ 四、无向图的邻接多重表表示——（Adjacency Multilist)本节介绍无向图的另一种链式存储结构——邻接多重表，这类存储结构对已被搜索过的边做记号或删除一条表尤为方便；由于采用将边存储为一个节点，以边的两个端点是否依附于该条边作为存储关系，故对有向图而言忽略了边的方向，不过结构与十字链表类似，因此此结构主要用于无向图； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//--------------------无向图的邻接多重表存储表示-----------------//#define Max_Vertex_Num 20#define MAX_Length_Info 10#define InfoType char#define VertexType string#define inp(i,x,y) for(i=x;i&lt;=y;i++)#define Status booltypedef enum{unvisited, visited}VisitIf;typedef enum {UDG, UDN }GraphKind; //{无向图，无向网}//------------------边结构定义--------------//typedef struct EBox{ VisitIf mark; // 访问标记 int ivex, jvex, weight; // 该边依附的两个顶点位置 struct EBox *ilink, *jlink; // 分别指向依附这两个顶点的下一条边 InfoType *info; // 该边信息指针 }EBox;//------------------顶点结构定义--------------//typedef struct VexBox{ VertexType data; // 节点数据域 EBox *firstedge; //指向第一条依附该顶点的边 VexBox() { data = &quot;&quot;; firstedge = NULL; }}VexBox, AMList[Max_Vertex_Num];//-------------------图结构定义---------------//typedef struct{ AMList adjmulist; int vexnum, arcnum, kind, IncInfo; // 无向图的顶点数和边数}AMLGraph;int LocateVex(AMLGraph G, VertexType v);Status GraphAddNode(AMLGraph&amp; G, int p1, int p2, int w);Status CreateGraph(AMLGraph &amp;G);Status CreateUDG(AMLGraph &amp;G);Status CreateUDN(AMLGraph &amp;G);Status GraphPrint(AMLGraph G);int main(){ AMLGraph G; CreateGraph(G); GraphPrint(G); return 0;}Status CreateGraph(AMLGraph &amp;G){ cout &lt;&lt; &quot;Input the type of graph(0:UDG,1:UDN):\\n&quot;; cin &gt;&gt; G.kind; // 种类标识 switch(G.kind){ case UDG:return CreateUDG(G); case UDN:return CreateUDN(G); default:return false; }}Status CreateUDG(AMLGraph &amp;G){ // 采用邻接多重表存储表示，构造无向图G(G.kind=UDG) cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo; int i = 0; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.adjmulist[i].data; // 节点顶点值 cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { // 输入各弧并构造十字链表 VertexType v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; // 由于以边为单元，对两个节点的firstedge都做修改因此只需一次添加即可 GraphAddNode(G, p1, p2, 1); // p1&lt;-&gt;p2 } return true;}Status CreateUDN(AMLGraph &amp;G){ // 采用邻接多重表存储表示，构造无向网G(G.kind=UDN) cout &lt;&lt; &quot;Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):\\n&quot;; cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum &gt;&gt; G.IncInfo; int i = 0; cout &lt;&lt; &quot;Input Graph Node Sign:\\n&quot;; inp(i, 0, G.vexnum - 1) cin &gt;&gt; G.adjmulist[i].data; // 节点顶点值 cout &lt;&lt; &quot;Input two vertices of the edges:\\n&quot;; inp(i, 0, G.arcnum - 1) { // 输入各弧并构造十字链表 VertexType v1, v2; int w = 0; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; // 输入一条边的顶点 int p1 = LocateVex(G, v1), p2 = LocateVex(G, v2); if (p1 == -1 || p2 == -1) return false; // 由于以边为单元，对两个节点的firstedge都做修改因此只需一次添加即可 GraphAddNode(G, p1, p2, w); // p1&lt;-&gt;p2 } return true;}int LocateVex(AMLGraph G, VertexType v){ int i = 0; inp(i, 0, G.vexnum - 1) { if (G.adjmulist[i].data == v) return i; } return -1;}Status GraphAddNode(AMLGraph&amp; G, int p1, int p2, int w){ EBox* p = (EBox*)malloc(sizeof(EBox)); // 创建边单元 if (!p) return false; //邻接多重表——涉及两个链表的交接==&gt;最终firstedge指针会指向最后输入的一组数据 *p = {unvisited, p1, p2, w, G.adjmulist[p1].firstedge, G.adjmulist[p2].firstedge, NULL }; // 对弧节点赋值 //{mark, ivex, jvex, weight, *ilink, *jlink, *info} G.adjmulist[p1].firstedge = G.adjmulist[p2].firstedge = p; // 完成在入弧和出弧链头的插入 if (G.IncInfo) { p-&gt;info = (char*)malloc(MAX_Length_Info*sizeof(char)); cout &lt;&lt; &quot;Input the arc information: &quot;; cin &gt;&gt; p-&gt;info; } return true;}Status GraphPrint(AMLGraph G){ cout &lt;&lt; &quot;----------------Output Graph Information-----------------\\n&quot;; cout &lt;&lt; &quot;Graph Kind: &quot;; switch (G.kind) { case UDG:cout &lt;&lt; &quot;undirected graph\\n&quot;; //undiagraph break; case UDN:cout &lt;&lt; &quot;undirected nets\\n&quot;; //undianetwork break; default:return false; } cout &lt;&lt; &quot;Vextices number: &quot; &lt;&lt; G.vexnum &lt;&lt; &quot; &quot; &lt;&lt; &quot;Arcs number: &quot; &lt;&lt; G.arcnum &lt;&lt; endl; int i = 0, j = 0; cout &lt;&lt; endl &lt;&lt; &quot;----------------Vextices Vector Information----------------\\n&quot;; cout &lt;&lt; &quot;The Nodes Path:\\n&quot;; inp(i, 0, G.vexnum - 1) { EBox* p = G.adjmulist[i].firstedge; int Degree = 0, pos = 0; cout &lt;&lt; &quot;Paths: &quot;; while (p) { pos = (p-&gt;ivex == i)?p-&gt;jvex:p-&gt;ivex; if(G.IncInfo) cout &lt;&lt; G.adjmulist[i].data &lt;&lt; p-&gt;info &lt;&lt; &quot;-&lt;&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;&gt;-&quot; &lt;&lt; G.adjmulist[pos].data &lt;&lt; &quot; &quot;; else cout &lt;&lt; G.adjmulist[i].data &lt;&lt; &quot;-&lt;&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;&gt;-&quot; &lt;&lt; G.adjmulist[pos].data &lt;&lt; &quot; &quot;; p = (p-&gt;ivex == i)?p-&gt;ilink:p-&gt;jlink; Degree++; } cout &lt;&lt; endl &lt;&lt; G.adjmulist[i].data; cout &lt;&lt; &quot; Vextice Degree: &quot; &lt;&lt; Degree &lt;&lt; &quot; Outdegree: &quot; &lt;&lt; Degree&lt;&lt; &quot; Indegree: &quot; &lt;&lt; Degree &lt;&lt; &quot;\\n\\n&quot;; } return true;} 这里给出一个算例演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//----------------Here is a undirected graph demo--------------///*Input the type of graph(0:UDG,1:UDN):0Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):7 6 0Input Graph Node Sign:A B C D E F G Input two vertices of the edges:A CA FA DB EG EE D----------------Output Graph Information-----------------Graph Kind: undirected graphVextices number: 7 Arcs number: 6----------------Vextices Vector Information----------------The Nodes Path:Paths: A-&lt;1&gt;-D A-&lt;1&gt;-F A-&lt;1&gt;-CA Vextice Degree: 3 Outdegree: 3 Indegree: 3Paths: B-&lt;1&gt;-EB Vextice Degree: 1 Outdegree: 1 Indegree: 1Paths: C-&lt;1&gt;-AC Vextice Degree: 1 Outdegree: 1 Indegree: 1Paths: D-&lt;1&gt;-E D-&lt;1&gt;-AD Vextice Degree: 2 Outdegree: 2 Indegree: 2Paths: E-&lt;1&gt;-D E-&lt;1&gt;-G E-&lt;1&gt;-BE Vextice Degree: 3 Outdegree: 3 Indegree: 3Paths: F-&lt;1&gt;-AF Vextice Degree: 1 Outdegree: 1 Indegree: 1Paths: G-&lt;1&gt;-EG Vextice Degree: 1 Outdegree: 1 Indegree: 1*///----------------Here is a undrected net demo-----------------///*Input the type of graph(0:UDG,1:UDN):1Input Vextices number, Arcs number and Incinformation(Yes:1,NO:0):7 8 0 Input Graph Node Sign:A B C D E F GInput two vertices and weight of the edges:A C 4A F -2A D 4B E -9G E 7E D 3D B 1G F 2----------------Output Graph Information-----------------Graph Kind: undirected netsVextices number: 7 Arcs number: 8----------------Vextices Vector Information----------------The Nodes Path:Paths: A-&lt;4&gt;-D A-&lt;-2&gt;-F A-&lt;4&gt;-CA Vextice Degree: 3 Outdegree: 3 Indegree: 3Paths: B-&lt;1&gt;-D B-&lt;-9&gt;-EB Vextice Degree: 2 Outdegree: 2 Indegree: 2Paths: C-&lt;4&gt;-AC Vextice Degree: 1 Outdegree: 1 Indegree: 1Paths: D-&lt;1&gt;-B D-&lt;3&gt;-E D-&lt;4&gt;-AD Vextice Degree: 3 Outdegree: 3 Indegree: 3Paths: E-&lt;3&gt;-D E-&lt;7&gt;-G E-&lt;-9&gt;-BE Vextice Degree: 3 Outdegree: 3 Indegree: 3Paths: F-&lt;2&gt;-G F-&lt;-2&gt;-AF Vextice Degree: 2 Outdegree: 2 Indegree: 2Paths: G-&lt;2&gt;-F G-&lt;7&gt;-EG Vextice Degree: 2 Outdegree: 2 Indegree: 2*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA/"},{"title":"堆排序","text":"堆排序本文主要分享学习堆排序算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;#define MAXSIZE 100#define Status bool#define KeyType int#define InfoType int#define LT(x, y) (x&lt;y?1:0)typedef struct{ KeyType key; //关键字类型 InfoType info; // 数据项}ElemType;typedef struct{ ElemType r[MAXSIZE+1]; int length;}SqList; // 顺序表类型typedef SqList HeapType; // 堆类型Status HeapAdjust(HeapType &amp;H, int s, int m);Status HeapSort(HeapType &amp;H);int main(){ HeapType H; cout &lt;&lt; &quot;Input the length of the sequence:\\n&quot;; cin &gt;&gt; H.length; for(int i=1;i&lt;=H.length;i++) cin &gt;&gt; H.r[i].key; HeapSort(H); cout &lt;&lt; &quot;After Heap Sorting output the sequence:\\n&quot;; for(int i=1;i&lt;=H.length;i++) cout &lt;&lt; H.r[i].key &lt;&lt; &quot; &quot;; return 0;}Status HeapAdjust(HeapType &amp;H, int s, int m){ // 除H.r[s].key之外其余元素均满足堆的定义 // 本函数调整H.r[s]的关键字使得H.r[s...m]成为一个大顶堆 ElemType rc = H.r[s]; for(int j=2*s;j&lt;=m;j*=2){ // 沿key较大的孩子节点向下筛选 //下句主要从s的孩子节点中挑选最大值，j为其下标 //判定j&lt;m因为当只有一个孩子即左孩子时不需移动 j if(j&lt;m &amp;&amp; LT(H.r[j].key, H.r[j+1].key)) j++; if(!LT(rc.key, H.r[j].key)) break; H.r[s] = H.r[j]; // 更新较大值（向上传递） s = j; // 沿较大孩子所在子树向下筛选 } H.r[s] = rc; // 最终定位 return true;}Status HeapSort(HeapType &amp;H){ // 对顺序表H进行堆排序 for(int i=H.length/2;i&gt;0;--i) // 初始对所有元素建立大顶堆 HeapAdjust(H, i, H.length); for(int i=H.length;i&gt;1;i--){ ElemType temp = H.r[1]; // 每次最大值在堆顶H.r[1] H.r[1] = H.r[i]; // 每次和最后一个元素交换即输出元素后最后一个元素上堆顶 H.r[i] = temp; HeapAdjust(H, 1, i-1); // 重新调整 } return true;} 给出一个算例演示 1234567/*Input the length of the sequence:849 38 65 97 76 13 27 49After Heap Sorting output the sequence:13 27 38 49 49 65 76 97 */","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"归并排序","text":"2-路归并排序本文主要介绍学习2-路归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;#define Status bool#define Max_num 100#define LT(x,y) (x&lt;y?1:0)/*-------------2-路归并排序-------------*/typedef struct{ int key;}RcdType;typedef struct{ RcdType r[Max_num]; int length;}SqList;//---------------非递归算法-------------Status NonCurMerge(SqList &amp;L);Status MergeSort(RcdType *SR, RcdType *TR, int i, int m, int n);//-----------------递归算法--------------Status CurMerge(SqList &amp;L);Status MSort(RcdType *SR, RcdType *TR, int s, int t);int main(){ SqList L1, L2; cout &lt;&lt; &quot;Input the length of sequence: &quot;; cin &gt;&gt; L1.length; cout &lt;&lt; &quot;Input the elements of the sequence:\\n&quot;; for(int i=1;i&lt;=L1.length;i++) cin &gt;&gt; L1.r[i].key; L2 = L1; //------- 非递归算法--------- NonCurMerge(L1); cout &lt;&lt; &quot;Output the sequence with NonCurrSortAlgorithm:\\n&quot;; for(int i=1;i&lt;=L1.length;i++) cout &lt;&lt; L1.r[i].key &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; //--------递归算法------------ CurMerge(L2); cout &lt;&lt; &quot;Output the sequence with CurrSortAlgorithm:\\n&quot;; for(int i=1;i&lt;=L2.length;i++) cout &lt;&lt; L2.r[i].key &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;}Status NonCurMerge(SqList &amp;L){ int delta = 1, n = L.length; SqList T;T.length = n; // 内存辅助空间 while(delta &lt; n){ for(int i=1;i&lt;=n;i+=2*delta){ if(i+2*delta&gt;n) MergeSort(L.r,T.r,i,i+delta-1,n); else MergeSort(L.r,T.r,i,i+delta-1,i+2*delta-1); } L = T; // 赋值转换存储方向 delta *= 2; } return true;}Status MergeSort(RcdType *SR, RcdType *TR, int i, int m, int n){ // 有序表归并函数 SR[i...m]、SR[m+1...n]----&gt;TR[i...n] int j = m+1, k = i; while(i&lt;=m&amp;&amp;j&lt;=n){ // 取最小值 if(LT(SR[i].key, SR[j].key)) TR[k++] = SR[i++]; else TR[k++] = SR[j++]; } while(i&lt;=m) TR[k++] = SR[i++]; while(j&lt;=n) TR[k++] = TR[j++]; return true;}// --------------递归算法-------------------Status CurMerge(SqList &amp;L){ // 对顺序表进行归并排序 MSort(L.r, L.r, 1, L.length); return true;}Status MSort(RcdType *SR, RcdType *TR, int s, int t){ // 将SR[s..t]归并排序到TR[s...t] RcdType TRtemp[Max_num]; // 内存辅助空间 if(s==t) TR[s] = SR[s]; else{ int m = (s + t)/2; MSort(SR, TRtemp, s, m); MSort(SR, TRtemp, m+1, t); MergeSort(TRtemp, TR, s, m, t); } return true; } 给出一个算例演示 123456789/*Input the length of sequence: 10Input the elements of the sequence:9 8 7 6 5 4 3 2 1 0Output the sequence with NonCurrSortAlgorithm:0 1 2 3 4 5 6 7 8 9Output the sequence with CurrSortAlgorithm:0 1 2 3 4 5 6 7 8 9*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"快速排序","text":"快速排序本文主要介绍快速排序以及基于三者取中法则的改进算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;using namespace std;#define MAXSIZE 100#define Status bool#define KeyType int#define InfoType inttypedef struct{ KeyType key; //关键字类型 InfoType info; // 数据项}ElemType;typedef struct{ ElemType r[MAXSIZE+1]; int length;}SqList; // 顺序表类型/*---------------快速排序---------------*/int Partition(SqList &amp;L, int low, int high);// 利用三者取中法则改进int AdvancedPartition(SqList &amp;L, int low, int high);Status QuickSort(SqList &amp;L);Status QSort(SqList &amp;L, int low,int high);int main(){ SqList L; cout &lt;&lt; &quot;Input the length of sequence: &quot;; cin &gt;&gt; L.length; for(int i=0;i&lt;L.length;i++){ cin &gt;&gt; L.r[i+1].key; } QuickSort(L); cout &lt;&lt; &quot;After quick sorting output the sequence:\\n&quot;; for(int i=0;i&lt;L.length;i++){ cout &lt;&lt; L.r[i+1].key &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0;}Status QuickSort(SqList &amp;L){ // 对顺序表做快速排序 QSort(L, 1, L.length); return true;}Status QSort(SqList &amp;L, int low,int high){ if(low &lt; high){ // 长度大于1 int piv = AdvancedPartition(L, low, high); // 寻找枢轴位置 // 由于枢轴位置已到位，故跳过枢轴位，将序列一分为二，递归排序 QSort(L, low, piv-1); QSort(L, piv+1, high); } return true;}int Partition(SqList &amp;L, int low, int high){ // 寻找枢轴函数，在low和high之间寻找枢轴，使枢轴记录到位，并返回其位置 // 使得枢轴之前(后)均不大于(小于)它 L.r[0] = L.r[low]; // 暂存 int piv = L.r[low].key; // 子表的第一个记录当作枢轴 while(low &lt; high) { while(low&lt;high &amp;&amp; L.r[high].key &gt;= piv) high--; L.r[low] = L.r[high]; // 将记录移到低位 while(low&lt;high &amp;&amp; L.r[low].key &lt;= piv) low++; L.r[high] = L.r[low]; // 将记录移到高位 } L.r[low] = L.r[0]; // 枢轴记录到位 return low; // 返回枢轴位置}int AdvancedPartition(SqList &amp;L, int low, int high){ // 利用三者取中规则寻找枢轴函数 int piv = 0, inpiv = 0; // 记录子表的枢轴,枢轴下标 int maxv = L.r[low].key &gt; L.r[high].key?low:high; int minv = low + high - maxv; int midv = (low+high)/2; if(L.r[midv].key &lt; L.r[minv].key) inpiv = minv; else if(L.r[midv].key &gt; L.r[maxv].key) inpiv = maxv; else inpiv = midv; // 进行转换 L.r[0] = L.r[inpiv]; piv = L.r[inpiv].key; if(inpiv != low) L.r[inpiv] = L.r[low]; while(low &lt; high) { while(low&lt;high &amp;&amp; L.r[high].key &gt;= piv) high--; L.r[low] = L.r[high]; // 将记录移到低位 while(low&lt;high &amp;&amp; L.r[low].key &lt;= piv) low++; L.r[high] = L.r[low]; // 将记录移到高位 } L.r[low] = L.r[0]; // 枢轴记录到位 return low; // 返回枢轴位置} 给出一个算例演示 123456789101112/*//-------demo 1-------Input the length of sequence: 101 2 3 4 5 6 7 8 9 10After quick sorting output the sequence:5 1 6 2 3 7 8 9 4 10//-------demo 2--------Input the length of sequence: 1049 38 65 97 76 13 27 49 55 04After quick sorting output the sequence:4 13 27 38 49 49 55 65 76 97*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"拓扑排序","text":"一、拓扑排序二、AOV网与 AOE网1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;cstring&gt;#include&quot;ADL.h&quot;#define inp(i,x,y) for(i=x;i&lt;=y;i++) #define Max_Vertex_Num 20//-------------------AOV-------------------//Status FindInDegree(ALGraph G, int *indegree);Status TopologicalSort(ALGraph G, int *T, int &amp;Ttop);Status CriticalPath(ALGraph G);int ve[Max_Vertex_Num]; // 顶点事件最早发生时间int vl[Max_Vertex_Num]; // 顶点事件最迟发生时间int main(){ ALGraph G, GR; CreateGraph(G, GR); GraphPrint(G, GR); CriticalPath(G); return 0;}Status TopologicalSort(ALGraph G, int *T, int &amp;Ttop){ // 有向无环图的拓扑排序 //求各顶点时间的最早发生时间ve(全局变量) //若G无回路，则用T返回G的一个拓扑序列，且函数返回OK，否则返回ERROR int S[Max_Vertex_Num], Stop = -1, i = 0; /*栈St的指针为top*/ int *indegree = new int[G.vexnum]; if(!FindInDegree(G, indegree)) return false; //indegree顶点入度 inp(i,0,G.vexnum-1) if(!indegree[i]) S[++Stop] = i; int count = 0; cout &lt;&lt; &quot;Directed acycline graph topologicalsort:\\n&quot;; while(Stop &gt; -1) { /*栈不为空时循环*/ i = S[Stop--]; T[++Ttop] = i; // i号顶点入T栈 count++; cout &lt;&lt; G.Vextices[i].data &lt;&lt; &quot; &quot;; // 输出拓扑排序 for(ArcNode* p=G.Vextices[i].firstarc; p; p=p-&gt;nextarc){ int k = p-&gt;adjvex; // 邻接弧头节点位置 if(--indegree[k]==0) S[++Stop] = k; // 零入度进栈 if(ve[i]+p-&gt;weight &gt; ve[k]) ve[k] = ve[i] + p-&gt;weight; } } cout &lt;&lt; endl; delete[] indegree; if(count &lt; G.vexnum) return false; // 有回路 else return true;}// TopologicalOrderStatus FindInDegree(ALGraph G, int *indegree) { int i; //inp(i,0,G.vexnum-1) indegree[i] = 0; memset(indegree, 0, G.vexnum*sizeof(int)); inp(i,0,G.vexnum-1){ //扫描邻接表，计算各顶点的入度 for(ArcNode *p=G.Vextices[i].firstarc; p; p=p-&gt;nextarc) indegree[p-&gt;adjvex]++; } return true;}Status CriticalPath(ALGraph G){ // G为有向网，输出G的各项关键活动 int T[Max_Vertex_Num], Ttop = -1, j = 0; // 存储拓扑排序序列，模拟栈 //建立用于产生拓扑逆序的栈T if(!TopologicalSort(G, T, Ttop)){ cout &lt;&lt; &quot;This graph has a cicle.\\n&quot;; return false; //该有向网有回路返回false }else cout &lt;&lt; &quot;--------------Critical Path Table-----------------\\n&quot;; inp(j,0,G.vexnum-1) vl[j] = ve[G.vexnum-1]; //初始化顶点事件的最迟发生时间 while (Ttop &gt; -1){ //按拓扑逆序求各顶点的vl值 j = T[Ttop--]; for(ArcNode *p=G.Vextices[j].firstarc; p; p=p-&gt;nextarc){ int k = p-&gt;adjvex, dut = p-&gt;weight; // dut&lt;j,k&gt; // vl[k]已经求得，与j各邻接弧k的所有vl[k]-dut要最小，保证耗时最长的相对于vl[k]能准时 if(vl[k] - dut &lt; vl[j]) vl[j] = vl[k] - dut; // min(vl(k)-dut&lt;j,k&gt;) }// for } //while // 求e、l和关键活动 cout &lt;&lt; &quot;Activities on edge:\\n&quot;; cout &lt;&lt; &quot;---------------------------------------------\\n&quot;; cout &lt;&lt; &quot;| Edge | duration | e | l | l-e | CriActi |\\n&quot;; // title inp(j,0,G.vexnum-1) for (ArcNode *p = G.Vextices[j].firstarc; p; p = p-&gt;nextarc) { int k = p-&gt;adjvex, dut= p-&gt;weight; int ee = ve[j], el = vl[k]-dut; string tag = (ve[j]==(vl[k]-dut))? &quot;Yes&quot;:&quot;No &quot;; cout &lt;&lt; &quot;|&lt;&quot; &lt;&lt; G.Vextices[j].data &lt;&lt; &quot;, &quot; &lt;&lt; G.Vextices[k].data &lt;&lt; &quot;&gt;| &quot;; cout &lt;&lt; dut &lt;&lt; &quot; | &quot; &lt;&lt; ee &lt;&lt; &quot; | &quot; &lt;&lt; el &lt;&lt; &quot; | &quot; &lt;&lt; el-ee &lt;&lt; &quot; | &quot; &lt;&lt; tag &lt;&lt; &quot; |\\n&quot;; //输出关键活动 } cout &lt;&lt; &quot;---------------------------------------------\\n&quot;; cout &lt;&lt; &quot;Events on vertex:\\n&quot;; cout &lt;&lt; &quot;--------------------\\n&quot;; cout &lt;&lt; &quot;| Vertex | ve | vl |\\n&quot;; //title inp(j,0,G.vexnum-1) cout &lt;&lt; &quot;| &quot; &lt;&lt; G.Vextices[j].data &lt;&lt; &quot; | &quot; &lt;&lt; ve[j] &lt;&lt; &quot; | &quot; &lt;&lt; vl[j] &lt;&lt; &quot; |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------\\n&quot;; return true;}//CriticalPath 给出一个算例演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167//------------------Here is a demo----------------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):1Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):6 8 0Input Graph Node Sign:V1 V2 V3 V4 V5 V6Input two vertices and weight of the edges:V1 V2 3V2 V5 3V2 V4 2V1 V3 2V3 V4 4V4 V6 2V3 V6 3V5 V6 1----------------Output Graph Information-----------------Graph Kind: directed netsVextices number: 6 Arcs number: 8----------------Vextices Vector Information----------------The Nodes Path:Out path: V1-[3]-&gt;V2 V1-[2]-&gt;V3In path:V1 Vextice Degree: 2 Outdegree: 2 Indegree: 0Out path: V2-[3]-&gt;V5 V2-[2]-&gt;V4In path: V1-[3]-&gt;-V2V2 Vextice Degree: 3 Outdegree: 2 Indegree: 1Out path: V3-[4]-&gt;V4 V3-[3]-&gt;V6In path: V1-[2]-&gt;-V3V3 Vextice Degree: 3 Outdegree: 2 Indegree: 1Out path: V4-[2]-&gt;V6In path: V2-[2]-&gt;-V4 V3-[4]-&gt;-V4V4 Vextice Degree: 3 Outdegree: 1 Indegree: 2Out path: V5-[1]-&gt;V6In path: V2-[3]-&gt;-V5V5 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path:In path: V4-[2]-&gt;-V6 V3-[3]-&gt;-V6 V5-[1]-&gt;-V6V6 Vextice Degree: 3 Outdegree: 0 Indegree: 3Directed acycline graph topologicalsort:V1 V3 V2 V4 V5 V6--------------Critical Path Table-----------------Activities on edge:---------------------------------------------| Edge | duration | e | l | l-e | CriActi ||&lt;V1, V2&gt;| 3 | 0 | 1 | 1 | No ||&lt;V1, V3&gt;| 2 | 0 | 0 | 0 | Yes ||&lt;V2, V5&gt;| 3 | 3 | 4 | 1 | No ||&lt;V2, V4&gt;| 2 | 3 | 4 | 1 | No ||&lt;V3, V4&gt;| 4 | 2 | 2 | 0 | Yes ||&lt;V3, V6&gt;| 3 | 2 | 5 | 3 | No ||&lt;V4, V6&gt;| 2 | 6 | 6 | 0 | Yes ||&lt;V5, V6&gt;| 1 | 6 | 7 | 1 | No |---------------------------------------------Events on vertex:--------------------| Vertex | ve | vl || V1 | 0 | 0 || V2 | 3 | 4 || V3 | 2 | 2 || V4 | 6 | 6 || V5 | 6 | 7 || V6 | 8 | 8 |--------------------*///----------------Here is another demo------------///*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):1Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):9 11 0Input Graph Node Sign:V1 V2 V3 V4 V5 V6 V7 V8 V9Input two vertices and weight of the edges:V1 V2 6V1 V3 4V1 V4 5V2 V5 1V3 V5 1V4 V6 2V5 V7 9V5 V8 7V6 V8 4V7 V9 2V8 V9 4----------------Output Graph Information-----------------Graph Kind: directed netsVextices number: 9 Arcs number: 11----------------Vextices Vector Information----------------The Nodes Path:Out path: V1-[6]-&gt;V2 V1-[4]-&gt;V3 V1-[5]-&gt;V4In path:V1 Vextice Degree: 3 Outdegree: 3 Indegree: 0Out path: V2-[1]-&gt;V5In path: V1-[6]-&gt;-V2V2 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: V3-[1]-&gt;V5In path: V1-[4]-&gt;-V3V3 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: V4-[2]-&gt;V6In path: V1-[5]-&gt;-V4V4 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: V5-[9]-&gt;V7 V5-[7]-&gt;V8In path: V2-[1]-&gt;-V5 V3-[1]-&gt;-V5V5 Vextice Degree: 4 Outdegree: 2 Indegree: 2Out path: V6-[4]-&gt;V8In path: V4-[2]-&gt;-V6V6 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: V7-[2]-&gt;V9In path: V5-[9]-&gt;-V7V7 Vextice Degree: 2 Outdegree: 1 Indegree: 1Out path: V8-[4]-&gt;V9In path: V5-[7]-&gt;-V8 V6-[4]-&gt;-V8V8 Vextice Degree: 3 Outdegree: 1 Indegree: 2Out path:In path: V7-[2]-&gt;-V9 V8-[4]-&gt;-V9V9 Vextice Degree: 2 Outdegree: 0 Indegree: 2Directed acycline graph topologicalsort:V1 V4 V6 V3 V2 V5 V8 V7 V9--------------Critical Path Table-----------------Activities on edge:---------------------------------------------| Edge | duration | e | l | l-e | CriActi ||&lt;V1, V2&gt;| 6 | 0 | 0 | 0 | Yes ||&lt;V1, V3&gt;| 4 | 0 | 2 | 2 | No ||&lt;V1, V4&gt;| 5 | 0 | 3 | 3 | No ||&lt;V2, V5&gt;| 1 | 6 | 6 | 0 | Yes ||&lt;V3, V5&gt;| 1 | 4 | 6 | 2 | No ||&lt;V4, V6&gt;| 2 | 5 | 8 | 3 | No ||&lt;V5, V7&gt;| 9 | 7 | 7 | 0 | Yes ||&lt;V5, V8&gt;| 7 | 7 | 7 | 0 | Yes ||&lt;V6, V8&gt;| 4 | 7 | 10 | 3 | No ||&lt;V7, V9&gt;| 2 | 16 | 16 | 0 | Yes ||&lt;V8, V9&gt;| 4 | 14 | 14 | 0 | Yes |---------------------------------------------Events on vertex:--------------------| Vertex | ve | vl || V1 | 0 | 0 || V2 | 6 | 6 || V3 | 4 | 6 || V4 | 5 | 8 || V5 | 7 | 7 || V6 | 7 | 10 || V7 | 16 | 16 || V8 | 14 | 14 || V9 | 18 | 18 |--------------------*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"最短路算法","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&quot;MGraph.h&quot;//-----------------最短路算法--------------//// 采用邻接矩阵存储表示//-----------------Dijkstra算法求最短路径--------------//Status DijsMinPath(MGraph G, int v0);Status DispDijsPaths(MGraph G, int *D, int *fa, bool *final, int v0);Status MinDijsPrint(MGraph G, int *fa, int v, int v0);//-----------------Floyd算法求最短路径--------------//Status FloydMinPath(MGraph G);Status MinFloydPrint(MGraph G, int *path, int v, int w); Status DispFloydPaths(MGraph G, int *D, int *path);int main(){ MGraph G; CreateGraph(G); GraphPrint(G); cout &lt;&lt; &quot;----------------------Dijkstra MinPath Problem Page------------------\\n&quot;; cout &lt;&lt; &quot;Input the source node: &quot;; VertexType sv; cin &gt;&gt; sv; int v0 = LocateVex(G, sv); DijsMinPath(G, v0); cout &lt;&lt; &quot;-----------------------Floyd MinPath Problem Page---------------------\\n&quot;; FloydMinPath(G); return 0;}/*-------------------------------Dijkstra ALgorithm-----------------------*/Status DijsMinPath(MGraph G, int v0){ // D[v]表示v0到v的最短路径带权长度 // fa[v]=w表示通过w中转，即D(v0,w)+arc(w,v)便于回溯路径 // final[v]：标识数组，为True当且仅当v属于S, 即已经求得v0到v最短路 int fa[Max_Vertex_Num], D[Max_Vertex_Num]; bool final[Max_Vertex_Num]; int v = 0, w = 0, i = 0; // 初始化操作 inp(v,0, G.vexnum-1){ final[v] = false; D[v] = G.arcs[v0][v].adj; // v0到v邻接 if(D[v] != INFINITY) fa[v] = v0; // 路径回溯 } final[v0] = true; // 初始化节点v0属于S集 // 取min(d(v0,v)) v属于V-S, 即求剩余节点中到v0距离最短得节点v inp(i,1,G.vexnum-1){ // 当前所知离v0顶点的最近距离, 初始未找到为无穷大 int min_path = INFINITY; inp(w,0,G.vexnum-1){ if(!final[w]) // w节点在V-S中 if(D[w] &lt; min_path){ // 取min v = w; min_path = D[w]; } } // 将选中的节点即确定距离得节点加入S集中 if(min_path != INFINITY) final[v] = true; else break; // 通过新选的节点v中转更新V-S中节点距离操作 inp(w,0,G.vexnum-1){ if(!final[w] &amp;&amp; G.arcs[v][w].adj != INFINITY) // 避免最大值上溢问题的特判 if(min_path + G.arcs[v][w].adj &lt; D[w]){ D[w] = min_path + G.arcs[v][w].adj; fa[w] = v; // 上次中转节点 } } } DispDijsPaths(G, D, fa, final, v0); return true;}Status DispDijsPaths(MGraph G, int *D, int *fa, bool *final, int v0){ int i = 0; inp(i, 0, G.vexnum-1){ if(i != v0){ // 不包括源点 if(final[i]){ // 如果已确定最短距离 cout &lt;&lt; &quot;from &quot; &lt;&lt; G.vexs[v0] &lt;&lt; &quot; to &quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot; the shortest path length: &quot; &lt;&lt; D[i]; cout &lt;&lt; endl &lt;&lt; &quot;Display the path:\\n&quot; &lt;&lt; G.vexs[v0] &lt;&lt; &quot;-&gt;&quot;; /*输出路径上的起点*/ MinDijsPrint(G, fa, i, v0); /*输出路径上的中间点*/ cout &lt;&lt; G.vexs[i] &lt;&lt; endl; /*输出路径上的终点*/ } else cout &lt;&lt; &quot;from &quot; &lt;&lt; G.vexs[v0] &lt;&lt; &quot; to &quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot; there is no road.\\n&quot;; } } return true;}Status MinDijsPrint(MGraph G, int *fa, int v, int v0){ // 回溯输出v到v0的最短路径 int w = fa[v]; if(w == v0){ return true; // 找到了起点则返回 } MinDijsPrint(G, fa, w, v0); // 找w顶点的父顶点 cout &lt;&lt; G.vexs[w] &lt;&lt; &quot;-&gt;&quot;; return true;}/*-------------------------------Dijkstra ALgorithm-----------------------*//*-------------------------------Floyd ALgorithm--------------------------*/Status FloydMinPath(MGraph G){ // path[v][w]表示v到w最短路径上经过的最后一个节点即w的父节点 int path[G.vexnum][G.vexnum], D[G.vexnum][G.vexnum]; int i = 0, j = 0, k = 0; inp(i, 0, G.vexnum-1) //矩阵 D与 path初始化 inp(j, 0, G.vexnum-1){ D[i][j] = G.arcs[i][j].adj; if(D[i][j] != INFINITY) path[i][j] = i; // 头节点 else path[i][j] = -1; // i到j无路径 } // 生成D(k)及path(k) inp(k, 0, G.vexnum-1) inp(i, 0, G.vexnum-1) inp(j, 0, G.vexnum-1) // 加入Vk节点 if(D[i][k] != INFINITY &amp;&amp; D[k][j] != INFINITY) // 解决INF运算溢出的问题 if(D[i][j] &gt; D[i][k] + D[k][j]){ D[i][j] = D[i][k] + D[k][j]; path[i][j] = path[k][j]; //缩短路径长度, 经过 k 到 j //注解：相当于对&lt;i,j&gt;路径改向，&lt;i,j&gt;方向改为经k的&lt;k,j&gt;方向 } DispFloydPaths(G, &amp;D[0][0], &amp;path[0][0]); return true;}Status DispFloydPaths(MGraph G, int *D, int *path){ int i = 0, j = 0, k = 0; inp(i,0,G.vexnum-1){ cout &lt;&lt; &quot;-------------------------------------------------------------\\n&quot;; inp(j,0,G.vexnum-1){ if(i == j) continue; // 不包括节点自身 if(D[i*G.vexnum + j] != INFINITY){ cout &lt;&lt; &quot;from &quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot; to &quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; the shortest path length: &quot; &lt;&lt; D[i*G.vexnum + j] &lt;&lt; endl; cout &lt;&lt; &quot;Display the path:\\n&quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot;-&gt;&quot;; /*输出路径上的起点*/ MinFloydPrint(G, path, i, j); /*输出路径上的中间点*/ cout &lt;&lt; G.vexs[j] &lt;&lt; endl; /*输出路径上的终点*/ } else cout &lt;&lt; &quot;from &quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot; to &quot; &lt;&lt; G.vexs[j] &lt;&lt; &quot; there is no road.\\n&quot;; } cout &lt;&lt; &quot;-------------------------------------------------------------\\n&quot;; } return true;}Status MinFloydPrint(MGraph G, int *path, int v, int w) { // 回溯输出v到w的最短路径 int p = path[v*G.vexnum + w]; if(p == v){ return true; // 找到了起点则返回 } MinFloydPrint(G, path, v, p); // 找w顶点的父顶点 cout &lt;&lt; G.vexs[p] &lt;&lt; &quot;-&gt;&quot;; return true;}/*-------------------------------Floyd ALgorithm--------------------------*/ 一个算例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):1Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):6 8 0Input Graph Node Sign:V0 V1 V2 V3 V4 V5Input two vertices and weight of the edges:V0 V5 100V0 V4 30V0 V2 10V1 V2 5 V4 V5 60V4 V3 20V3 V5 10V2 V3 50Output Graph Information:Graph Kind: directed netsVextices number: 6 Arcs number: 8Vextices Vector Information:V0-&lt;0&gt;-V0 V0-&lt;10&gt;-V2 V0-&lt;30&gt;-V4 V0-&lt;100&gt;-V5 V0 Vextice Degree: 5 Outdegree: 4 Indegree: 1V1-&lt;0&gt;-V1 V1-&lt;5&gt;-V2V1 Vextice Degree: 3 Outdegree: 2 Indegree: 1V2-&lt;0&gt;-V2 V2-&lt;50&gt;-V3V2 Vextice Degree: 5 Outdegree: 2 Indegree: 3V3-&lt;0&gt;-V3 V3-&lt;10&gt;-V5V3 Vextice Degree: 5 Outdegree: 2 Indegree: 3V4-&lt;20&gt;-V3 V4-&lt;0&gt;-V4 V4-&lt;60&gt;-V5V4 Vextice Degree: 5 Outdegree: 3 Indegree: 2V5-&lt;0&gt;-V5V5 Vextice Degree: 5 Outdegree: 1 Indegree: 4----------------------Dijkstra MinPath Problem Page------------------Input the source node: V0from V0 to V1 there is no road.from V0 to V2 the shortest path length: 10Display the path:V0-&gt;V2from V0 to V3 the shortest path length: 50Display the path:V0-&gt;V4-&gt;V3from V0 to V4 the shortest path length: 30Display the path:V0-&gt;V4from V0 to V5 the shortest path length: 60Display the path:V0-&gt;V4-&gt;V3-&gt;V5-----------------------Floyd MinPath Problem Page----------------------------------------------------------------------------------from V0 to V1 there is no road.from V0 to V2 the shortest path length: 10Display the path:V0-&gt;V2from V0 to V3 the shortest path length: 50Display the path:V0-&gt;V4-&gt;V3from V0 to V4 the shortest path length: 30Display the path:V0-&gt;V4from V0 to V5 the shortest path length: 60Display the path:V0-&gt;V4-&gt;V3-&gt;V5--------------------------------------------------------------------------------------------------------------------------from V1 to V0 there is no road.from V1 to V2 the shortest path length: 5Display the path:V1-&gt;V2from V1 to V3 the shortest path length: 55Display the path:V1-&gt;V2-&gt;V3from V1 to V4 there is no road.from V1 to V5 the shortest path length: 65Display the path:V1-&gt;V2-&gt;V3-&gt;V5--------------------------------------------------------------------------------------------------------------------------from V2 to V0 there is no road.from V2 to V1 there is no road.from V2 to V3 the shortest path length: 50Display the path:V2-&gt;V3from V2 to V4 there is no road.from V2 to V5 the shortest path length: 60Display the path:V2-&gt;V3-&gt;V5--------------------------------------------------------------------------------------------------------------------------from V3 to V0 there is no road.from V3 to V1 there is no road.from V3 to V2 there is no road.from V3 to V4 there is no road.from V3 to V5 the shortest path length: 10Display the path:V3-&gt;V5--------------------------------------------------------------------------------------------------------------------------from V4 to V0 there is no road.from V4 to V1 there is no road.from V4 to V2 there is no road.from V4 to V3 the shortest path length: 20Display the path:V4-&gt;V3from V4 to V5 the shortest path length: 30Display the path:V4-&gt;V3-&gt;V5-------------------------------------------------------------from V5 to V0 there is no road.from V5 to V1 there is no road.from V5 to V2 there is no road.from V5 to V3 there is no road.from V5 to V4 there is no road.-------------------------------------------------------------*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"},{"title":"栈进阶数据结构","text":"一、栈维护最值时间复杂度 O(1)；设置三个栈 A、B、C，其中 A栈存储原始数据，B、C栈分别维护栈中最小值和最大值: 12345678// 进栈操作A.push(x);B.push(min(B.top(),x));C.push(max(C.top(),x));// 出栈操作A.pop();B.pop();C.pop(); 二、对顶栈应用思想：始终在序列中间某个指定位置进行修改；建立两个栈，A栈存储从序列开头到当前位置的这一段子序列，栈 B存储当前位置到序列结尾处的这一段子序列，二者都以当前位置那一端作为栈顶。栈求 最大前缀和 时，用一个数组 f维护栈 A的最大前缀和； 12345// A的栈顶位置下标pA，使用数组模拟栈// sum是A的前缀和数组A.push(x);sum[pA]=sum[pA-1]+A[pA];f[pA] = max(f[pA-1],sum[pA]); 三、单调栈单调栈算法：时间复杂度 O(N)，处理问题思想在于 及时排除不可能的选项，保持策略集合的高度有效性和秩序性应用：需要维护一个单调的序列并且可以不断从一端插入或删除典例：思路分析: 12345678910111213141516171819// 数组模拟栈：往往更快一些a[n+1] = p = 0; // p为栈顶位置，初始为0for(int i=1;i&lt;=n+1;i++){ if(a[i] &gt; s[p]){ // 矩形高度大于栈顶高度时直接进栈 s[++p] = a[i]; w[p] = 1; }else{ // 否则依次比较、寻找不高于当前矩形的位置 int width = 0; while(s[p] &gt; a[i]){ width += w[p];// 宽度叠加 // 这里s[p]是当前栈顶的高度值，ans记录最终的最大值 ans = max(ans, (long long)width*s[p]); p--; } // 更新栈，基于当前栈顶位置 s[++p] = a[i],w[p] = width + 1; }}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"非连通图生成森林","text":"一、深度优先生成森林本节实现对非连通图由深度优先搜索生成森林； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//----------------建立无向图的深度优先生成森林------------------//// 以孩子兄弟链表作生成森林的存储结构typedef struct CSNode { TElemType data; struct CSNode *firstchild, *nextsibling; }CSNode, *CSTree;Status DFSForest(ALGraph G, CSTree &amp;T){ // 建立无向图G的深度优先生成森林 CSTree p, q; T = NULL; int v = 0; inp(v,0,G.vexnum-1) visite[v] = unvisited; // 节点初始化 inp(v,0,G.vexnum-1) if(!visite[v]){ p = (CSTree) malloc(sizeof(CSNode)); *p = {G.Vextices[v].data, NULL, NULL}; if(!T) T = p; else q-&gt;nextsibling = p; // 是其他生成树的根 q = p; // q指示当前生成树的根 DFSTree(G, v, q); // 建立以p为根的生成树 } return true;}Status DFSTree(ALGraph G, int v, CSTree &amp;T){ // 从第v个顶点出发深度优先遍历图G，建立以T为根的生成树 CSTree p, q; visite[v] = visited; // 子树根节点已访问过 bool first = true; for(ArcNode *a=G.Vextices[v].firstarc; a; a=a-&gt;nextarc){ int w = a-&gt;adjvex; if(!visite[w]){ // 排除根节点的父代节点 p = (CSTree)malloc(sizeof(CSNode)); // 为当前遍历的节点申请空间 *p = {G.Vextices[w].data, NULL, NULL}; if(first) { T-&gt;firstchild = p; // 找到根节点的第一个孩子 first = false; } else q-&gt;nextsibling = p; // 其他孩子节点作为上一节点的右兄弟节点 q = p; // 更新上一节点 DFSTree(G, w, q); // 递归生成以q为根节点的子树 } } return ;} 注解：DFSForest()函数： 通过对所有节点遍历，如果节点未被访问过，申请节点空间，进行赋值存储； T指向整个森林的根节点，DFSTree()函数为连通子图生成一棵树，从一个连通子图中的一个节点进行深度优先搜索一定会遍历该连通子图中所有的节点； 因此对其他未被访问过的节点即是另一个连通子图上的节点，再次循环，将其连接在 q(指向上一棵树的根节点)的兄弟节点； 总体而言，DFSForest()函数是将各个连通子图转换成一棵树，再串联成森林；DFSTree()函数： 通过邻接点遍历，设置第一次访问(除了父代节点)为孩子节点，其余邻接点均通过 q记录上一个兄弟置于右兄弟位置上； 深度优先的体现：对当前节点的每一个邻接点，再次进行递归生成树，优先保证加深度而非加宽度(即优先遍历孩子节点而非优先遍历兄弟节点)； 二、广度优先生成森林本节实现对非连通图由广度优先搜索生成森林； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//----------------建立无向图的广度优先生成森林------------------//typedef struct QElem { // 用于广度优先生成树中元素结构 CSTree node; int v; }QElem;Status BFSForest(ALGraph G, CSTree &amp;T){ // 建立无向图G的广度优先生成森林 CSTree p, q; T = NULL; int v = 0; inp(v,0,G.vexnum-1) visite[v] = unvisited; // 节点初始化 inp(v,0,G.vexnum-1) if(!visite[v]){ p = (CSTree) malloc(sizeof(CSNode)); *p = {G.Vextices[v].data, NULL, NULL}; if(!T) T = p; else q-&gt;nextsibling = p; // 是其他生成树的根 q = p; // q指示当前生成树的根 BFSTree(G, v, q); // 建立以p为根的生成树 } return true;}Status BFSTree(ALGraph G, int v, CSTree &amp;T){ bool first = true; // 处理根节点 queue&lt;QElem&gt; Q; Q.push({T, v}); visite[v]=visited; while (!Q.empty()) { QElem e = Q.front(); Q.pop(); CSTree q = e.node; first = true; // 标记q节点的第一个孩子 // 在邻接表中搜寻当前节点未访问过的节点 for(ArcNode *a=G.Vextices[e.v].firstarc; a; a=a-&gt;nextarc){ int w = a-&gt;adjvex; if(!visite[w]){ CSTree p = (CSTree)malloc(sizeof(CSNode)); *p = {G.Vextices[w].data, NULL, NULL}; Q.push({p, w});visite[w] = visited; if(first){ q-&gt;firstchild = p; first = false; } else q-&gt;nextsibling = p; q = p; // 更新上一节点==&gt;指向上一兄弟 }//if }//for }//while return true;} 注解： DFSForest()函数同理，而 BFSTree()函数通过队列对根节点未被访问过的邻接点不断扩展； 广度优先的体现：对每一个从队列取出的当前节点扩展所有邻接点，即遍历构建除根节点外的其他所有孩子节点； 因此生成的森林中按照层序遍历，每一层都是尽量多节点的；综合后的代码：(其中 ADL.h是图的存储结构表示中给出的邻接表与逆邻接表表示方式) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include&lt;iostream&gt;#include&lt;queue&gt;#include&quot;ADL.h&quot;using namespace std;//-------------建立无向图的生成森林------------------//// 以孩子兄弟链表作生成森林的存储结构#define TElemType string#define inp(i,x,y) for(i=x;i&lt;=y;i++)#define Max_Vertex_Num 20typedef enum{unvisited, visited}VisitIf;typedef struct CSNode { TElemType data; struct CSNode *firstchild, *nextsibling; }CSNode, *CSTree;typedef struct QElem { // 用于广度优先生成树中元素结构 CSTree node; int v; }QElem;VisitIf visite[Max_Vertex_Num];//-------------------------生成森林函数---------------------------//Status CreateForest(ALGraph G, CSTree &amp;T, Status(*CreateTree)(ALGraph G, int v, CSTree &amp;T));Status DFSTree(ALGraph G, int v, CSTree &amp;T); // 深度优先Status BFSTree(ALGraph G, int v, CSTree &amp;T); // 广度优先//--------------------生成森林的遍历-------------------------//Status CSFPreRootOrder(CSTree T, Status(*Visit)(TElemType e)); // 先根遍历Status CSFPostRootOrder(CSTree T, Status(*Visit)(TElemType e)); // 后根遍历Status LevelOrderTraverse(CSTree T, Status(*Visit)(TElemType e)); // 层序遍历Status TreeTransOperator(TElemType e); // 二叉树遍历算子Status ForestPrint(CSTree T); // 森林输出函数int main(){ ALGraph G, GR; CreateGraph(G, GR); CSTree DFST, BFST; CreateForest(G, DFST, DFSTree); CreateForest(G, BFST, BFSTree); GraphPrint(G, GR); cout &lt;&lt; &quot;------------------------CS_Forest DFS Traverse-------------------------\\n&quot;; ForestPrint(DFST); cout &lt;&lt; endl &lt;&lt; &quot;------------------------CS_Forest BFS Traverse-------------------------\\n&quot;; ForestPrint(BFST); return 0;}Status CreateForest(ALGraph G, CSTree &amp;T, Status(*CreateTree)(ALGraph G, int v, CSTree &amp;T)){ // 建立无向图G的生成森林 CSTree p, q; T = NULL; int v = 0; inp(v,0,G.vexnum-1) visite[v] = unvisited; // 节点初始化 inp(v,0,G.vexnum-1) if(!visite[v]){ p = (CSTree) malloc(sizeof(CSNode)); *p = {G.Vextices[v].data, NULL, NULL}; if(!T) T = p; else q-&gt;nextsibling = p; // 是其他生成树的根 q = p; // q指示当前生成树的根 CreateTree(G, v, q); // 建立以p为根的生成树 } return true;}//-----------深度优先生成森林------------//Status DFSTree(ALGraph G, int v, CSTree &amp;T){ // 从第v个顶点出发深度优先遍历图G，建立以T为根的生成树 CSTree p, q; visite[v] = visited; // 子树根节点已访问过 bool first = true; for(ArcNode *a=G.Vextices[v].firstarc; a; a=a-&gt;nextarc){ int w = a-&gt;adjvex; if(!visite[w]){ // 排除根节点的父代节点 p = (CSTree)malloc(sizeof(CSNode)); // 为当前遍历的节点申请空间 *p = {G.Vextices[w].data, NULL, NULL}; if(first) { T-&gt;firstchild = p; // 找到根节点的第一个孩子 first = false; } else q-&gt;nextsibling = p; // 其他孩子节点作为上一节点的右兄弟节点 q = p; // 更新上一节点 DFSTree(G, w, q); // 递归生成以q为根节点的子树 } } return true;}//-----------广度优先生成森林------------//Status BFSTree(ALGraph G, int v, CSTree &amp;T){ bool first = true; // 处理根节点 queue&lt;QElem&gt; Q; Q.push({T, v}); visite[v]=visited; while (!Q.empty()) { QElem e = Q.front(); Q.pop(); CSTree q = e.node; first = true; // 标记q节点的第一个孩子 // 在邻接表中搜寻当前节点未访问过的节点 for(ArcNode *a=G.Vextices[e.v].firstarc; a; a=a-&gt;nextarc){ int w = a-&gt;adjvex; if(!visite[w]){ CSTree p = (CSTree)malloc(sizeof(CSNode)); *p = {G.Vextices[w].data, NULL, NULL}; Q.push({p, w});visite[w] = visited; if(first){ q-&gt;firstchild = p; first = false; } else q-&gt;nextsibling = p; q = p; // 更新上一节点==&gt;指向上一兄弟 }//if }//for }//while return true;}Status TreeTransOperator(TElemType e) // 二叉树遍历算子{ // 对数据元素操作的应用函数 cout &lt;&lt; e &lt;&lt; &quot; &quot;; return true;}Status CSFPreRootOrder(CSTree T, Status(*Visit)(TElemType e)) // 前根遍历{ if(T == NULL){ return true; } Visit(T-&gt;data); CSFPreRootOrder(T-&gt;firstchild, Visit); CSFPreRootOrder(T-&gt;nextsibling, Visit); return true;}Status CSFPostRootOrder(CSTree T, Status(*Visit)(TElemType e)) // 后根遍历{ if(T == NULL){ return true; } CSFPostRootOrder(T-&gt;firstchild, Visit); Visit(T-&gt;data); CSFPostRootOrder(T-&gt;nextsibling, Visit); return true;}Status LevelOrderTraverse(CSTree T, Status(*Visit)(TElemType e)){ if(T == NULL){ cout &lt;&lt; &quot;This is an empty tree.\\n&quot;; return true; } queue&lt;CSNode*&gt; q; q.push(T); int i = 0, width = 1; while(!q.empty()) { CSTree P; inp(i,0,width-1){ if(!q.empty()){ P = q.front();q.pop(); q.push(P); } while(P-&gt;nextsibling){ q.push(P-&gt;nextsibling); P = P-&gt;nextsibling; } } width = q.size(); cout &lt;&lt; &quot;Nodes number of the current layer: &quot; &lt;&lt; width &lt;&lt; &quot; &quot;; inp(i,0,width-1){ if(!q.empty()){ P = q.front();q.pop(); } Visit(P-&gt;data); if(P-&gt;firstchild) q.push(P-&gt;firstchild); } cout &lt;&lt; endl; } return true;}Status ForestPrint(CSTree T){ int i = 1; CSTree P = T; while(T){ cout &lt;&lt; &quot;--------------------Subtree &quot; &lt;&lt; i++ &lt;&lt;&quot;------------------\\n&quot;; cout &lt;&lt; &quot;CS_Forest First root Traverse:\\n&quot;; TreeTransOperator(T-&gt;data); CSFPreRootOrder(T-&gt;firstchild, TreeTransOperator); // 等于二叉树中先序 cout &lt;&lt; endl &lt;&lt; &quot;CS_Forest Post root Traverse:\\n&quot;; CSFPostRootOrder(T-&gt;firstchild, TreeTransOperator); // 等于二叉树中中序 TreeTransOperator(T-&gt;data); cout &lt;&lt; endl; T = T-&gt;nextsibling; } cout &lt;&lt; &quot;CS_Forest Level Traverse:\\n&quot;; LevelOrderTraverse(P, TreeTransOperator); return true;} 给出一个算例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/*Input the type of graph(0:DG,1:DN,2:UDG,3:UDN):2Input Vextices number, Arcs number and Incinformation(1:Yes,0:NO):13 13 0Input Graph Node Sign:A B C D E F G H I J K L MInput two vertices of the edges:A B A CA FA LL JL MJ MB MD EG HG KG IH K----------------Output Graph Information-----------------Graph Kind: undirected graphVextices number: 13 Arcs number: 13----------------Vextices Vector Information----------------The Nodes Path:Out path: A-&lt;-[1]-&gt;-B A-&lt;-[1]-&gt;-C A-&lt;-[1]-&gt;-F A-&lt;-[1]-&gt;-LA Vextice Degree: 4Out path: B-&lt;-[1]-&gt;-A B-&lt;-[1]-&gt;-MB Vextice Degree: 2Out path: C-&lt;-[1]-&gt;-AC Vextice Degree: 1Out path: D-&lt;-[1]-&gt;-ED Vextice Degree: 1Out path: E-&lt;-[1]-&gt;-DE Vextice Degree: 1Out path: F-&lt;-[1]-&gt;-AF Vextice Degree: 1Out path: G-&lt;-[1]-&gt;-H G-&lt;-[1]-&gt;-K G-&lt;-[1]-&gt;-IG Vextice Degree: 3Out path: H-&lt;-[1]-&gt;-G H-&lt;-[1]-&gt;-KH Vextice Degree: 2Out path: I-&lt;-[1]-&gt;-GI Vextice Degree: 1Out path: J-&lt;-[1]-&gt;-L J-&lt;-[1]-&gt;-M J Vextice Degree: 2Out path: K-&lt;-[1]-&gt;-G K-&lt;-[1]-&gt;-HK Vextice Degree: 2Out path: L-&lt;-[1]-&gt;-A L-&lt;-[1]-&gt;-J L-&lt;-[1]-&gt;-ML Vextice Degree: 3Out path: M-&lt;-[1]-&gt;-L M-&lt;-[1]-&gt;-J M-&lt;-[1]-&gt;-BM Vextice Degree: 3------------------------CS_Forest DFS Traverse---------------------------------------------Subtree 1------------------CS_Forest First root Traverse:A B M L J C F CS_Forest Post root Traverse:J L M B C F A--------------------Subtree 2------------------CS_Forest First root Traverse:D ECS_Forest Post root Traverse:E D--------------------Subtree 3------------------CS_Forest First root Traverse:G H K ICS_Forest Post root Traverse:K H I GCS_Forest Level Traverse:Nodes number of the current layer: 3 A D GNodes number of the current layer: 6 B C F E H INodes number of the current layer: 2 M KNodes number of the current layer: 1 LNodes number of the current layer: 1 J------------------------CS_Forest BFS Traverse---------------------------------------------Subtree 1------------------CS_Forest First root Traverse:A B M C F L JCS_Forest Post root Traverse:M B C F J L A--------------------Subtree 2------------------CS_Forest First root Traverse:D ECS_Forest Post root Traverse:E D--------------------Subtree 3------------------CS_Forest First root Traverse:G H K ICS_Forest Post root Traverse:H K I GCS_Forest Level Traverse:Nodes number of the current layer: 3 A D GNodes number of the current layer: 8 B C F L E H K INodes number of the current layer: 2 M J*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97/"},{"title":"直接插入排序","text":"插入排序本文主要介绍四种插入排序算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include&lt;iostream&gt;#include&lt;climits&gt;#include&lt;string&gt;using namespace std;#define inp(i,x,y) for(i=x;i&lt;=y;i++)#define dep(i,x,y) for(i=x;i&gt;=y;i--)#define Status bool#define MAXSIZE 100#define Max_time_num 4#define KeyType int #define InfoType string#define LT(x,y) (x &lt; y ? 1:0)typedef struct{ KeyType key; //关键字类型 InfoType info; // 数据项}ElemType;typedef struct{ ElemType r[MAXSIZE+1]; // r[0]作哨兵 int length;}SqList; // 顺序表类型// 表插入排序数据结构typedef struct{ KeyType key; int next;}SLNode;typedef struct{ SLNode r[MAXSIZE+1]; // 0号单元为表头结点 int length; // 链表当前长度}SLinkList; // 静态链表类型//----------------直接插入排序--------------Status InsertSort(SqList L);//----------------折半插入排序--------------Status BInsertSort(SqList L);//----------------表插入排序--------------Status ListInsertSort(SLinkList &amp;SL);Status Arrange(SLinkList &amp;SL); // 重排//-----------------希尔排序--------------Status ShellInsert(SqList &amp;L, int dk);Status ShellSort(SqList L,int* dlta,int t);int main(){ int i = 0, j = 0; SqList L; cin &gt;&gt; L.length; inp(i,1,L.length) cin &gt;&gt; L.r[i].key; // 进行排序 InsertSort(L); BInsertSort(L); // 希尔排序增量数组 int* dlta = new int[Max_time_num]; inp(i, 0, Max_time_num) if(i&lt;=2) dlta[i] = i+1; else if(i==3) dlta[i] = 5; else dlta[i] = 9; ShellSort(L, dlta, 3); // 表排序 SLinkList SL; cin &gt;&gt; SL.length; inp(i,1,SL.length){ cin &gt;&gt; SL.r[i].key; } SL.r[i].key = INT_MAX; if(ListInsertSort(SL)){ cout &lt;&lt; &quot;List InsertSort Result:\\n&quot;; inp(i,0,SL.length){ cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; SL.r[i].key &lt;&lt; &quot;, &quot; &lt;&lt; SL.r[i].next &lt;&lt; &quot;&gt; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; &quot;Rearrange Records Result:\\n&quot;; if(Arrange(SL)){ inp(i,1,SL.length){ cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; SL.r[i].key &lt;&lt; &quot;, &quot; &lt;&lt; SL.r[i].next &lt;&lt; &quot;&gt; &quot;; } cout &lt;&lt; endl; } delete[] dlta; return 0;}Status InsertSort(SqList L){ int i = 0, j = 0; // 对顺序表 L 进行直接插入排序 inp(i, 2, L.length){ if(LT(L.r[i].key, L.r[i-1].key)){ L.r[0] = L.r[i]; // 复制为哨兵 L.r[i] = L.r[i-1]; for(j=i-2;LT(L.r[0].key, L.r[j].key);j--) L.r[j+1] = L.r[j]; // 记录后移 L.r[j+1] = L.r[0]; // 插入正确位置j+1 } } cout &lt;&lt; &quot;InsertSort Result:\\n&quot;; inp(i,1,L.length) cout &lt;&lt; L.r[i].key &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return true;}Status BInsertSort(SqList L){ // 对顺序表L作折半插入排序 int i = 0, j = 0; inp(i, 2, L.length){ L.r[0] = L.r[i]; // 哨兵 int low = 1, high = i - 1; // 默认前i个位置已经排好序 while(low &lt;= high){ int m = (low + high) / 2; if(LT(L.r[0].key, L.r[m].key)) high = m-1; else low = m + 1; }// 结束条件是high &lt; low 退出时待插入位置即是high之后 low之前 dep(j,i-1,high+1) L.r[j+1] = L.r[j]; // 记录后移 L.r[high + 1] = L.r[0]; // high指向待插位置之前 //等价于 /* dep(j,i-1,low) L.r[j+1] = L.r[j]; // 记录后移 L.r[low] = L.r[0];*/ } cout &lt;&lt; &quot;Binary InsertSort Result:\\n&quot;; inp(i,1,L.length) cout &lt;&lt; L.r[i].key &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return true;}Status ListInsertSort(SLinkList &amp;SL){ // 初始化操作 SL.r[0].next = 1;SL.r[1].next = 0; int i=0,j=0,k=0; inp(i, 2, SL.length){ // j 指向前一节点 j = 0; k = SL.r[j].next; while(k &gt; 0 &amp;&amp; LT(SL.r[k].key, SL.r[i].key)){ j = k;k = SL.r[j].next; } SL.r[i].next = SL.r[j].next; // 移动指针 SL.r[j].next = i; } return true;}Status Arrange(SLinkList &amp;SL){ /*--------重排记录---------*/ // 根据静态链表SL中各节点的指针值调整记录位置，使得SL中记录按关键字非递减有序顺序排列 int i=0, j=0; int p = SL.r[0].next; // p指示第一个记录的当前位置 inp(i, 1, SL.length-1){ // p指向的是当前待调整的位置，默认前i个位置已经排好序 // 前i个位置已经定好顺序 // 当p &lt; i时，待调整元素已经被转移走了，因此需要往后寻找 while(p &lt; i) p = SL.r[p].next; int q = SL.r[p].next; // 获取尚未调整的下一元素，以防后面处理造成链表中断 if(p != i){ // 如果待调元素位置p不是i即第i个记录未到位 SLNode temp = SL.r[p]; SL.r[p] = SL.r[i]; SL.r[i] = temp; SL.r[i].next = p; } p = q; // 获取下一待定位元素位置 } return true; }Status ShellSort(SqList L, int* dlta, int t){ // 按增量序列dlta[0..t-1]对顺序表L进行希尔排序 int i = 0; inp(i,0,t-1){ ShellInsert(L, dlta[i]); } cout &lt;&lt; &quot;Shell InsertSort Result:\\n&quot;; inp(i,1,L.length) cout &lt;&lt; L.r[i].key &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return true;}Status ShellInsert(SqList &amp;L, int dk){ int i = 0, j = 0; inp(i,dk+1,L.length){ if(LT(L.r[i].key, L.r[i-dk].key)){ // 在不同增量下存在按增量前溯时不能到0位置，因此不能设置哨兵 L.r[0] = L.r[i]; // 暂存在r[0]位置 for(j=i-dk;j&gt;0 &amp;&amp; LT(L.r[0].key, L.r[j].key); j-=dk) // 子序列插入排序时子序列前溯 L.r[j+dk] = L.r[j]; // 记录后移 L.r[j+dk] = L.r[0]; } } return true;} 给出一个算例演示： 12345678910111213141516/*10 49 38 65 97 76 13 27 49 55 4 InsertSort Result:4 13 27 38 49 49 55 65 76 97 Binary InsertSort Result: 4 13 27 38 49 49 55 65 76 97 Shell InsertSort Result: 4 13 27 38 49 49 55 65 76 97 10 49 38 65 97 76 13 27 49 55 4List InsertSort Result:&lt;0, 10&gt; &lt;49, 9&gt; &lt;38, 8&gt; &lt;65, 5&gt; &lt;97, 0&gt; &lt;76, 4&gt; &lt;13, 7&gt; &lt;27, 2&gt; &lt;49, 1&gt; &lt;55, 3&gt; &lt;4, 6&gt; Rearrange Records Result:&lt;4, 10&gt; &lt;13, 6&gt; &lt;27, 7&gt; &lt;38, 6&gt; &lt;49, 8&gt; &lt;49, 10&gt; &lt;55, 9&gt; &lt;65, 9&gt; &lt;76, 4&gt; &lt;97, 0&gt; */","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"矩阵转置","text":"稀疏矩阵转置本文采用顺序存储结构的三元组表压缩存储稀疏矩阵，并基于此数据结构对稀疏矩阵进行转置，介绍两种转置处理方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;using namespace std;//---------------稀疏矩阵的三元组顺序表存储表示-------------#define MAXSIZE 500// 抽象数据类型定义typedef int ElemType;typedef bool Status;typedef struct { int i, j; ElemType value;}Triple;typedef struct { Triple data[MAXSIZE + 1]; int rows, cols, nums; // 行列和非零元数 }TSMatrix;Status TransposeMatrix(TSMatrix M, TSMatrix&amp; T);Status FastTransposeMatrix(TSMatrix M, TSMatrix&amp; FT);Status TSMatrixRead(TSMatrix&amp; M);Status TSMatrixPrint(TSMatrix M);int main(){ TSMatrix M, T, FT; TSMatrixRead(M); cout &lt;&lt; &quot;Before Transpose Matrix:\\n&quot;; TSMatrixPrint(M); cout &lt;&lt; &quot;After Transpose Matrix:\\n&quot;; TransposeMatrix(M, T); TSMatrixPrint(T); cout &lt;&lt; &quot;After FastTranspose Matrix:\\n&quot;; FastTransposeMatrix(M, FT); TSMatrixPrint(FT); return 0;}Status TransposeMatrix(TSMatrix M, TSMatrix&amp; T){ // 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T T.rows = M.cols; T.cols = M.rows; T.nums = M.nums; if (T.nums) { // 如果矩阵非空 int q = 1; for (int col = 1; col &lt;= M.cols; col++) { // 指定循环M列序保证T矩阵的行主序 for (int p = 1; p &lt;= M.nums; p++) { // 搜寻M中当前列元素 // M又是按照行主序存储的，所以M每一列的列序即是T中每一行的行序 if (M.data[p].j == col) { T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i; T.data[q].value = M.data[p].value; q++; } } } } return true;}Status FastTransposeMatrix(TSMatrix M, TSMatrix&amp; FT){ // 快速转置算法 // 采用三元组表存储表示，求稀疏矩阵M的转置矩阵T FT.rows = M.cols; FT.cols = M.rows; FT.nums = M.nums; if (FT.nums) { // 矩阵非空 int* num = new int[M.cols + 1]; int* cpot = new int[M.cols + 1]; // 记录矩阵M中每一列的元素个数 for (int col = 1; col &lt;= M.cols; col++) num[col] = 0; for (int t = 1; t &lt;= M.nums; ++t) ++num[M.data[t].j]; // 记录矩阵M中，每一列的首非零元在三元组表中的下标位置 cpot[1] = 1; // 默认第一个元素从首位置开始 for (int col = 2; col &lt;= M.cols; col++) cpot[col] = cpot[col - 1] + num[col - 1]; // 累加定位 for (int p = 1; p &lt;= M.nums; p++) { int col = M.data[p].j; int q = cpot[col]; // 提取位置编号 // 元素放置 FT.data[q].i = M.data[p].j; FT.data[q].j = M.data[p].i; FT.data[q].value = M.data[p].value; // 后移控制=====&gt;填充三元组表 cpot[col]++; } delete[] num; } return true;}Status TSMatrixRead(TSMatrix&amp; M){ cout &lt;&lt; &quot;Input Matrix rows, cols and nums:\\n&quot;; cin &gt;&gt; M.rows &gt;&gt; M.cols &gt;&gt; M.nums; cout &lt;&lt; &quot;Input Matrix elements:\\n&quot;; // 这里默认输入是行主序的 for (int i = 1; i &lt;= M.nums; i++) { cin &gt;&gt; M.data[i].i &gt;&gt; M.data[i].j &gt;&gt; M.data[i].value; } return true;}Status TSMatrixPrint(TSMatrix M){ // 由三元组表输出标准矩阵 int cnt = 1; for (int i = 1; i &lt;= M.rows; i++) { for (int j = 1; j &lt;= M.cols; j++) { if (M.data[cnt].i == i &amp;&amp; M.data[cnt].j == j) cout &lt;&lt; M.data[cnt++].value &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;0 &quot;; } cout &lt;&lt; endl; } return true;} 这里给出一个演示算例： 1234567891011121314151617181920212223/*Input Matrix rows, cols and nums:3 4 4Input Matrix elements:1 1 31 4 52 2 -13 1 2Before Transpose Matrix:3 0 0 50 -1 0 02 0 0 0After Transpose Matrix:3 0 20 -1 00 0 05 0 0After FastTranspose Matrix:3 0 20 -1 00 0 05 0 0*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/"},{"title":"赫夫曼树","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;//------------赫夫曼树和赫夫曼编码的存储表示-----------//typedef struct { // 赫夫曼树节点 char sign; // 待编码字符 int weight; //节点值 unsigned int parent, lchild, rchild;}HTNode, * HuffmanTree;typedef struct{ // 动态分配数组存储赫夫曼编码表 char **NodesCode; // 字符对应编码 char *sign; // 字符}HuffmanCode;void Select(HuffmanTree HT, int p, int&amp; s1, int&amp; s2);void HuffmanCoding(HuffmanTree&amp; HT, HuffmanCode&amp; HC, int* w, char *s, int n);void HuffmanCodePrint(HuffmanCode HC, int n);int main(){ HuffmanTree HT; HuffmanCode HC; int n; cout &lt;&lt; &quot;Input the number of chars: &quot;; cin &gt;&gt; n; int *w = new int[n]{}; char *s = new char[n]{}; cout &lt;&lt; &quot;Input n chars in the tuple:(char, weight):\\n&quot;; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s[i] &gt;&gt; w[i]; } HuffmanCoding(HT, HC, w, s, n); HuffmanCodePrint(HC, n); return 0;}void Select(HuffmanTree HT, int p, int&amp; s1, int&amp; s2){ s1 = s2 = 0; for (int i = 1; i &lt;= p; i++) { if (HT[i].parent) continue; else { if (!s1) s1 = i; // 保证先有节点 else if (!s2) { if (HT[s1].weight &gt; HT[i].weight) { s2 = s1; s1 = i; } else s2 = i; } else { if (HT[i].weight &lt; HT[s1].weight) { s2 = s1; s1 = i; } else if (HT[i].weight &lt; HT[s2].weight) { s2 = i; } } } } return;}void HuffmanCoding(HuffmanTree&amp; HT, HuffmanCode&amp; HC, int* w, char *s, int n){ // w存放n个字符的权值，构造赫夫曼树HT，并求出n个字符的赫夫曼编码HC if (n &lt;= 1) return; int m = 2 * n - 1; // 赫夫曼树的节点数 HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode)); // 0号单元未用 HuffmanTree p = HT; int i = 1; for (p=HT+1; i &lt;= n; ++i, ++p, ++w, ++s) *p = {*s,*w,0,0,0 }; // 对赫夫曼树叶子节点进行赋值 for (; i &lt;= m; i++, p++) *p = {0,0,0,0,0 }; // 其他节点初始化操作 for (i = n + 1; i &lt;= m; i++) { // 建赫夫曼树 //在HT[1..i-1]选择parent为0且weight最小的两个节点，其序号分别为s1和s2 int s1 = 0, s2 = 0; Select(HT, i - 1, s1, s2); HT[s1].parent = i; HT[s2].parent = i; // 更新构造 HT[i].lchild = s1; HT[i].rchild = s2; HT[i].weight = HT[s1].weight + HT[s2].weight; } //--------从叶子到根逆向求每个字符的赫夫曼编码-------------// HC.NodesCode = (char**)malloc((n + 1) * sizeof(char*)); // 分配n个字符编码的头指针向量 HC.sign = (char*)malloc((n+1) * sizeof(char)); char* cd = (char*)malloc(n * sizeof(char)); // 分配n个字符求编码的工作空间，最长编码是n-1 cd[n - 1] = '\\0'; // 编码结束符 for (i = 1; i &lt;= n; ++i) { // 遍历叶子节点（前n个位置） int start = n - 1; // 编码结束符位置 for (int c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent) // 从叶子到根逆向求编码 if (HT[f].lchild == c) cd[--start] = '0'; // 左孩子定义为0 else cd[--start] = '1'; // 右孩子定义为1 HC.NodesCode[i] = (char*)malloc((n - start) * sizeof(char)); // 为第i个字符编码分配空间 HC.sign[i] = HT[i].sign; strcpy(HC.NodesCode[i], &amp;cd[start]); } free(cd); return;}void HuffmanCodePrint(HuffmanCode HC, int n){ cout &lt;&lt; &quot;Chars Huffmancodes:\\n&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; HC.sign[i] &lt;&lt; &quot;: &quot; &lt;&lt; HC.NodesCode[i] &lt;&lt; endl; } return;} 具体的一个算例演示 12345678910111213141516171819202122/*//-------------Here is a demo---------//Input the number of chars: 8Input n chars in the tuple:(char, weight):A 1 B 2 C 3 D 4 E 5F 6G 7H 8Chars Huffmancodes:A: 11110B: 11111C: 1110D: 100E: 101F: 110G: 00H: 01*/","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"},{"title":"链表与邻接表","text":"一、链表数组模拟双向链表 1234567891011121314151617181920212223242526272829303132333435363738struct Node{ int value; int prev, next;}node[SIZE];int head, tail, tot;void initialize(){ tot = 2; //控制节点存储位置 head = 1,tail = 2; node[head].next = tail; node[tail].prev = head; return ;}void insert(int p, int val){ // 在p点后向链表中插入一个节点 q = ++tot; // 向节点数组中申请空间 node[q].value = val; // 交接 node[node[p].next].prev = q; node[q].next = node[p].next; node[p].next = q; return ;}void remove(int p){ // 移除p节点 node[node[p].prev].next = node[p].next; node[node[p].next].prev = node[p].prev; return ;}void clear(){ memset(node, 0, sizeof(node)); head = tail = tot = 0; return ;} 二、二叉平衡树1pass 三、邻接表 邻接表：带有索引数组的多个数据链表构成的结构集合； 在这样的结构中存储的数据被分成若干类，每一类的数据构成一个链表； 每一类数据有一个代表元素，成为该类数据对应链表的“表头”； 所有“表头”构成一个表头数组，作为一个可以随机访问的索引；如上图所示，在插入新节点时，通过表头数组直接索引到对应数据类的链表处，并在链表表头处插入数据。 图论应用 123456789101112// 加入有向边(x,y),权值zvoid add(int x,int y,int z){ ver[++tot] = y, edge[tot] = z;// 记录真实数据 next[tot] = head[x],head[x] = tot; // 在表头x处插入 // 通过head[x]索引对应的边，首先将上次head[x]更换next数组值，再次将当前边终点位置更新head[x] return ;}// 访问从x出发的所有边for(int i = head[x];i;i = next[i]){ int y = ver[i],z = edge[i];} 注解：head与 next数组存储 ver数组的下标，相当于指针，其中用 0表示空；ver数组存储每条边的终点，是真实数据；","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"title":"队列进阶数据结构","text":"一、基本队列相对等效对于给定的一个序列，如果每次操作都需要改变大部分数据，数学运算一个相同的算子，而只有少部分数据不需要改变；则可以通过逆向改变少部分数据，赋予一个逆算子，进行相应运算化简，记录相对差量，最终换算为数据结果。 应用分析思路：其中应当证明在依次选取 $x_1, x_2$ 时，对应的第一秒后 $[px_1], x_1-[px_1], x_2+q$，在 $x_2$ 的一秒后 $[px_1]+q, x_1-[px_1]+q, [p(x_2+q)], (x_2+q)-[p(x_2+q)]$，则易证 $[px_1]+q &gt; [p(x_2+q)]$， $x_1-[px_1]+q &gt; (x_2+q)-[p(x_2+q)]$，进而推广到任意两段满足 $x_1 &gt;= x_2$ 时，只要 $x_1$ 在 $x_2$ 之前被取出，不论之后是否接着取 $x_2$，还是直接取 $x_1$ 分出的两端，或是其他段，都等效于最开始的 $x_2$。 二、单调队列——基于双端队列单调队列是指队列中元素之间的关系始终保持单调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。（注意是始终保持）单调队列功能：在每次加入或者删除元素时都保持序列里的元素有序，即队首元素始终是最小值或者最大值。 最大子序和——单调队列算法最优策略集合：下标位置递增、对应的前缀和 S的值也递增 1234567891011int l = 1, r = 1; // l指向队头，r指向队尾q[1] = 0; // 保存决策的基于数组的模拟队列for(int i=1;i&lt;=n;i++){ // 枚举最右端节点i // Step 1: while(l &lt;= r &amp;&amp; (i - q[l]) &gt; m) l++; // 边界判断，最多只能选m个数，否则队首出队 // Step 2: ans = max(ans, sum[i]-sum[q[l]]); // 寻找最大值，sum[]表示数组前缀和 // Step 3: while(l &lt;= r &amp;&amp; sum[q[r]] &gt;= sum[i]) r--; //更新，删除不小于i结点对应的队列元素 q[++r] = i;} 时间复杂度：$O(N)$注解： $Step 1$：检查队首，如果队首指向的下标小于等于 $i-m$，即相对于 $i$ 而言，队首的元素已经跑出区间 $[i-m+1, i]$，子序列长度超过了 $m$，那么弹出队首元素，对应操作 $l++$；对最大连续子序列和问题而言，在上一轮中队首元素对应的最长子序列的和已经计算并比较存入 $ans$ 中，此时进入新元素后，队首元素已经属于无效元素，所以直接出队； $Step 2$：相对于右端点 $i$ 而言，队首元素 $q[l]$ 对应的便是最优左端点 $j$； $Step 3$：检查队尾，如果队尾元素大于或等于要添加的值，则弹出队尾元素，对应操作 $r- -$，目的就是保持队首元素一直是最小值，且队列单调； $Step 4$：更新队尾，$q[++r]=i$，首先 $++r$ 为新元素腾出位置，加入元素的下标；解释： 根据前面分析的结论，以相对于右端点 $i$ 来看，如果 $sum[q[r]] &gt;= sum[i]$，最大连续子序列和一定不会是 $q[r]$ 对应的元素节点,因为此时 $sum[q[l]] &lt;= sum[q[r]]$，比较而言 $q[l]$ 更优； 如果不弹出 $q[r]$,那么当 $q[l]==q[r]$ 时，此时会出现 $sum(q[l]) &gt;= sum(q[l+1])$,很明显在这种条件下，决策 $q[l+1]$ 优于决策 $q[l]$，因为相对于右端点 $i$ 选 $q[l+1]$ 可以获得不劣于 $q[l]$ 的最大连续和，因此没有必要保留 $q[r]$; $q[i]$ 替换 $q[r]$ 机制，当需要弹出队尾元素 $q[r]$ 时，$r- -$ 之后 $Step 4$ 再次更新序列对应元素处在队列中的决策下标为新元素节点 $q[i]$，当下一轮 $l==r$ 时，$q[l]=q[i]$ 直接索引下一元素的下标； 单调队列思想：在决策集合（队列）中及时排除一定不是最优解的选择。单调队列模板： 123456789int data[N+1]; // 原始数据序列集合int q[N]; // 用于模拟单调队列的数组int k = Nnum; // 支持的最大区间长度int head = 1,tail = 1; // 初始队列没有元素for(int i=1;i&lt;=N;i++){ while(head &lt;= tail and q[head] &lt;= i - k) head++; //队首检查：保证队列长度合法 while(head &lt;= tail and data[q[tail]] &gt;= data[i]) tail--; // 队尾检查：保证队列单调性 q[++tail] = i; //插入新元素}","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"顺序栈","text":"栈的顺序存储表示 1、顺序存储结构利用一组地址连续的存储单元顺序栈定义： 12345typedef struct{ SElemType *base; // 栈底指针 SElemType *top; // 栈顶指针 int stacksize; // 当前栈的最大容量 }Sqstack; 注：当用数组作为存储结构时，可以用下标代替指针 2、基本操作算法描述对栈的常用操作做简要描述： 栈的初始化 123456789Status InitStack(SqStack &amp;S){ // 构造空栈S S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if(!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;} 以初始化容量申请一块连续的内存，S.top=S.base保证 top=base时栈空。 返回栈顶元素 123456Status GetTop(SqStack S, SElemType &amp;e){ if(S.top == S.base) return ERROR; e = *(S.base-1); return OK;} 压栈操作 12345678910111213Status Push(SqStack &amp;S, SElemType e){ //首先判断是否栈满 if(S.top-S.base &gt;= S.stacksize){ S.base = (SElemType *)realloc(S.base, (S.stacksize+STACKINCREMENT) * sizeof(SElemType)); //申请增量空间 if(!S.base) exit(OVERFLOW); // 更新回原来位置 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } *S.top++ = e; return OK;} 出栈操作 1234567Status Pop(SqStack &amp;S, SElemType &amp;e){ // 栈空标志 if(S.top == S.base) return ERROR; e = *--S.top; return OK;} 判断栈空 12345Status StackEmpty(SqStack S){ if(S.base == S.top) return true; return false;} 清空栈 123456Status ClearStack(SqStack &amp;S){ // 利用栈空标志进行清空 S.top = S.base; return OK;} 释放栈空间 12345Status DestroyStack(SqStack &amp;S){ if(S.base != NULL) free(S.base); return OK;} 3、栈的应用举例3.1 数制转换十进制数与其他d进制数转换时，一个简单算法原理：N = (N div d) X d + N mod d,其中 div表示整除操作，mod表示求余操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;typedef int SElemType;typedef bool Status;const bool OK = true;const bool ERROR = false;const SElemType STACK_INIT_SIZE = 100;const SElemType STACKINCREMENT = 10;typedef struct{ SElemType *base; // 栈底指针 SElemType *top; // 栈顶指针 int stacksize; // 当前栈的最大容量 }SqStack;Status InitStack(SqStack &amp;S){ // 构造空栈S S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if(!S.base) exit(EOVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;}Status Push(SqStack &amp;S, SElemType e){ //首先判断是否栈满 if(S.top-S.base &gt;= S.stacksize){ S.base = (SElemType *)realloc(S.base, (S.stacksize+STACKINCREMENT) * sizeof(SElemType)); //申请增量空间 if(!S.base) exit(EOVERFLOW); // 更新回原来位置 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } *S.top++ = e; return OK;}Status Pop(SqStack &amp;S, SElemType &amp;e){ // 栈空标志 if(S.top == S.base) return ERROR; e = *--S.top; return OK;}Status StackEmpty(SqStack S){ if(S.base == S.top) return true; return false;}Status Conversion(){ SqStack S; InitStack(S); SElemType data; int Obj = 0; cin &gt;&gt; data &gt;&gt; Obj; while(data){ Push(S,data % Obj); data = data/Obj; } while(!StackEmpty(S)) { SElemType e; if(!Pop(S,e)) break; cout &lt;&lt; e; } cout &lt;&lt; endl; return OK;}int main(){ // 对于输入的十进制数和目标进制，打印输出目标进制数 Conversion(); return 0;} 3.2 行编辑程序将用户从键盘输入的符号存入一个输入缓冲区，然后逐行存入用户数据区；这个过程允许用户删除字符，删除整行字符基本操作规则： 123# 退格符@ 退行符^ 结束符 程序实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;typedef char SElemType;typedef bool Status;const bool OK = true;const bool ERROR = false;const SElemType STACK_INIT_SIZE = 100;const SElemType STACKINCREMENT = 10;typedef struct{ SElemType *base; // 栈底指针 SElemType *top; // 栈顶指针 int stacksize; // 当前栈的最大容量 }SqStack;Status InitStack(SqStack &amp;S){ // 构造空栈S S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if(!S.base) exit(EOVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;}Status Push(SqStack &amp;S, SElemType e){ //首先判断是否栈满 if(S.top-S.base &gt;= S.stacksize){ S.base = (SElemType *)realloc(S.base, (S.stacksize+STACKINCREMENT) * sizeof(SElemType)); //申请增量空间 if(!S.base) exit(EOVERFLOW); // 更新回原来位置 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } *S.top++ = e; return OK;}Status Pop(SqStack &amp;S, SElemType &amp;e){ // 栈空标志 if(S.top == S.base) return ERROR; e = *--S.top; return OK;}Status StackEmpty(SqStack S){ if(S.base == S.top) return true; return false;}Status StackPrint(SqStack S){ SElemType *mp = S.base; while(mp != S.top){ putchar(*mp); mp++; } putchar('\\n'); return OK;}Status ClearStack(SqStack &amp;S){ // 利用栈空标志进行清空 S.top = S.base; return OK;}Status DestroyStack(SqStack &amp;S){ if(S.base != NULL) free(S.base); return OK;} Status LineEdit(){ //构造字符栈 SqStack S; InitStack(S); SElemType ch; ch = getchar(); //从终端接受一个字符 while(ch != '^'){ while(ch != '^' &amp;&amp; ch != '\\n'){ switch(ch){ case '#':Pop(S,ch); //退字符 break; case '@':ClearStack(S); //退行 break; default:Push(S,ch); //字符入栈 } ch = getchar(); //从终端接受下一个字符 } //对缓冲区的一行字符存入数据区，这里只是打印输出 StackPrint(S); ClearStack(S); if(ch != '^') ch = getchar(); } DestroyStack(S); return OK;}int main(){ LineEdit(); return 0;} 3.3 括号匹配问题给定一个包含各种括号的表达式，判断是否满足括号匹配利用栈操作，可在线性时间内检查出是否匹配，具体实现如下： 利用 STL模板库 123456789101112bool paren(const char exp[]) { //表达式括号匹配检查，可兼顾三种括号 Stack&lt;char&gt; S; //使用栈记录已出现但尚未匹配的左括号 for (int i = 0; exp[i]; i++) /* 逐一检查当前字符 */ switch (exp[i]) { //左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配 case '(': case '[': case '{': S.push(exp[i]); break; case ')': if ((S.empty()) || ('(' != S.pop())) return false; break; case ']': if ((S.empty()) || ('[' != S.pop())) return false; break; case '}': if ((S.empty()) || ('{' != S.pop())) return false; break; default: break; //非括号字符一律忽略 } return S.empty(); //整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配} 自定义栈操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;typedef char SElemType; //栈元素类型typedef bool Status;const bool OK = true;const bool ERROR = false;const SElemType STACK_INIT_SIZE = 100;const SElemType STACKINCREMENT = 10;typedef struct{ SElemType *base; // 栈底指针 SElemType *top; // 栈顶指针 int stacksize; // 当前栈的最大容量 }SqStack;Status InitStack(SqStack &amp;S){ // 构造空栈S S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); if(!S.base) exit(EOVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;}Status Push(SqStack &amp;S, SElemType e){ //首先判断是否栈满 if(S.top-S.base &gt;= S.stacksize){ S.base = (SElemType *)realloc(S.base, (S.stacksize+STACKINCREMENT) * sizeof(SElemType)); //申请增量空间 if(!S.base) exit(EOVERFLOW); // 更新回原来位置 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; } *S.top++ = e; return OK;}SElemType Pop(SqStack &amp;S){ // 栈空标志 if(S.top == S.base) return ERROR; return *--S.top;}Status StackEmpty(SqStack S){ if(S.base == S.top) return true; return false;}Status paren(){ //构造字符栈 SqStack S; InitStack(S); SElemType ch; ch = getchar(); while(ch != '\\n'){ switch (ch) { //左括号直接进栈；右括号若不栈顶失配，则表达式必不匹配 case '(': case '[': case '{': Push(S, ch); break; case ')': if ((StackEmpty(S)) || ('(' != Pop(S))) return false; break; case ']': if ((StackEmpty(S)) || ('[' != Pop(S))) return false; break; case '}': if ((StackEmpty(S)) || ('{' != Pop(S))) return false; break; default: break; //非括号字符一律忽略 } ch = getchar(); } return StackEmpty(S);}int main(){ if(paren()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0;} 3.4 表达式求值 延迟缓冲 在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后,才能作出判断并实施计算。在这类场合，栈结构则可以扮演数据缓冲区的角色。 表达式求值 关于运算符执行次序的规则(即运算优先级)，一部分决定于事先约定的惯例(比如乘除优先于加减)，另一部分则决定于括号。也就是说，仅根据表达式的某一前缀，并不能完全确定其中各运算符可否执行以及执行的次序；只有在已获得足够多后续信息之后，才能确定其中哪些运算符可以执行。 由于栈基本结构较为简单，常用操作内容上文已经介绍，因此本代码在此处调用 STL中 stack模板直接进行相关操作。 定义优先级表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;stack&gt;using namespace std;#define N_OPTR 9 //运算符总数#define Opr 100 //表达式最大长度typedef enum {ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE} Operator; //运算符集合 //加、减、乘、除、乘斱、阶乘、左括号、右括号、起始符不终止符const char pri[N_OPTR][N_OPTR] = { //运算符优先等级 [栈顶] [弼前]/* |-------------- 当前运算符 --------------| *//* + - * / ^ ! ( ) \\0 *//* -- + */ '&gt;', '&gt;', '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '&gt;', '&gt;',/* | - */ '&gt;', '&gt;', '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '&gt;', '&gt;',/* 栈 * */ '&gt;', '&gt;', '&gt;', '&gt;', '&lt;', '&lt;', '&lt;', '&gt;', '&gt;',/* 顶 / */ '&gt;', '&gt;', '&gt;', '&gt;', '&lt;', '&lt;', '&lt;', '&gt;', '&gt;',/* 运 ^ */ '&gt;', '&gt;', '&gt;', '&gt;', '&gt;', '&lt;', '&lt;', '&gt;', '&gt;',/* 算 ! */ '&gt;', '&gt;', '&gt;', '&gt;', '&gt;', '&gt;', ' ', '&gt;', '&gt;',/* 符 ( */ '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '=', ' ',/* | ) */ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',/* -- \\0*/ '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', '&lt;', ' ', '='};void readNumber(char*&amp; p, stack&lt;float&gt;&amp; stk) { //将起始于p癿子串解析为数值，并存入操作数栈 stk.push((float)(*p - '0')); //当前数位对应的数值进栈 // 处理多位整数情况 while (isdigit(*(++p))){ float temp = stk.top(); stk.pop(); stk.push(temp * 10 + (*p - '0')); //弹出原操作数，转换新数值重新入栈 } if ('.' != *p) return ; //此后非小数点，则意味着当前操作数解析完成 //处理小数部分 fraction设置挺关键 float fraction = 1; //否则，意味着还有小数部分 while (isdigit(*(++p))){ //逐位加入 float temp = stk.top(); stk.pop(); stk.push(temp + (*p - '0')*(fraction /= 10)); //小数部分 } return ;}Operator optr2rank(char op) { //由运算符转译出编号 switch (op) { case '+' : return ADD; //加 case '-' : return SUB; //减 case '*' : return MUL; //乘 case '/' : return DIV; //除 case '^' : return POW; //乘斱 case '!' : return FAC; //阶乘 case '(' : return L_P; //左括号 case ')' : return R_P; //右括号 case '\\0': return EOE; //起始符与终止符 default : exit(-1); //未知运算符 }}char orderBetween(char op1, char op2) //比较两个运算符之间的优先级{ return pri[optr2rank(op1)][optr2rank(op2)]; }void append(char*&amp; rpn, float opnd) { //将操作数接至RPN末尾 char buf[64] = {0}; //分数值类型进行压栈 if (opnd != (float)(int)opnd) sprintf(buf, &quot;%.2f \\0&quot;, opnd); //浮点格式，或 else sprintf(buf, &quot;%d \\0&quot;, (int)opnd); //整数格式 if(rpn==NULL){ rpn = (char*) malloc(sizeof(char) * (strlen(buf) + 1)); strcpy(rpn,buf); } else{ int n = strlen(rpn); //RPN当前长度（以'\\0'结尾，长度n + 1） rpn = (char*) realloc(rpn, sizeof(char) * (n + strlen(buf) + 1)); //扩展空间 strcat(rpn, buf); //RPN加长 } return ;}void append(char*&amp; rpn, char optr) { //将运算符接至RPN末尾 if(rpn == NULL){ rpn = (char*) malloc(sizeof(char) * (3)); sprintf(rpn, &quot;%c &quot;, optr); rpn[2] = '\\0'; //接入指定癿运算符 } else{ int n = strlen(rpn); //RPN当前长度（以'\\0'结尾，长度n + 1） rpn = (char*) realloc(rpn, sizeof(char) * (n + 3)); //扩展空间 sprintf(rpn + n, &quot;%c &quot;, optr); rpn[n + 2] = '\\0'; //接入指定癿运算符 } return ;}int calcu(char op, float data){ // 一元计算 if((int)data == 0) return 0; int sum_data = 1; for(int i=1;i&lt;=(int)data;i++) sum_data *= i; return sum_data;}float calcu(float opd1,char op, float opd2){ //前后操作数 switch(op){ case '+': return opd1+opd2; break; case '-': return opd1-opd2; break; case '*': return opd1*opd2; break; case '/': return opd1/opd2; break; case '^': return pow(opd1,opd2); break; default: return 0; break; }}bool evaluate(char* S, char*&amp; RPN, float &amp;result) { //对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN stack&lt;float&gt; opnd; stack&lt;char&gt; optr; //运算数栈、运算符栈 optr.push('\\0'); //尾哨兵'\\0'也作为头哨兵首先入栈，主要为了判断计算结束退出 while (!optr.empty()) { //在运算符栈非空之前，逐个处理表达式中各字符 if (isdigit(*S)) { //若当前字符为操作数，则 readNumber(S, opnd); // 读入操作数 append(RPN, opnd.top()); //并将其接至RPN末尾 } else //若当前字符为运算符，则 switch(orderBetween(optr.top(), *S)) { //视其与栈顶运算符之间优先级高低分别处理 case '&lt;': //栈顶运算符优先级更低时 optr.push(*S); S++; //计算推迟，当前运算符入栈 break; case '=': //优先级相等（当前运算符为右括号或者尾部哨兵'\\0'）时 optr.pop(); S++; //脱括号并接收下一个字符 break; case '&gt;': { //栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈 char op = optr.top(); optr.pop(); append(RPN, op); //栈顶运算符出栈并续接至RPN末尾 if ('!' == op) { //若属于一元运算符 float pOpnd = opnd.top(); //叧需取出一个操作数，并 opnd.pop(); opnd.push(calcu(op, pOpnd)); //实施一元计算，结果入栈 } else { //对于其它（二元）运算符 float pOpnd2 = opnd.top(); opnd.pop(); float pOpnd1 = opnd.top(); //取出后、前操作数 opnd.pop(); opnd.push(calcu(pOpnd1, op, pOpnd2)); //实施二元计算，结果入栈 } break; } default: return false; //逢语法错误，并做处理直接退出 }//switch }//while result = opnd.top(); opnd.pop(); return true; //弹出并返回最后的计算结果}int main(){ float ans = 0; char* RPN = NULL; char S[Opr] = {0}; cin &gt;&gt; S; if(evaluate(S,RPN,ans)) cout &lt;&lt; &quot;Ans = &quot; &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; &quot;Error!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Reverse Polish Notation:\\n&quot;; cout &lt;&lt; RPN; return 0;} 算法计算示例:计算给定表达式 (0!+1)*2^(3!+4)-(5!-67-(8+9))的值运行结果 123Ans = 988Reverse Polish Notation:0 ! 1 + 2 3 ! 4 + ^ * 5 ! 67 - 8 9 + - -","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E6%A0%88/"}],"tags":[{"name":"数据结构与算法 - LeetCode","slug":"数据结构与算法-LeetCode","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-LeetCode/"},{"name":"概率论与数理统计 - 数学","slug":"概率论与数理统计-数学","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E5%AD%A6/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"体系结构","slug":"体系结构","link":"/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"嵌入式系统","slug":"嵌入式系统","link":"/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"计算机原理","slug":"计算机原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"Generative Model","slug":"Generative-Model","link":"/tags/Generative-Model/"},{"name":"数字信号处理","slug":"数字信号处理","link":"/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"数据库系统","slug":"数据库系统","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"稀疏矩阵","slug":"稀疏矩阵","link":"/tags/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法竞赛","slug":"算法竞赛","link":"/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"categories":[{"name":"专业复习","slug":"专业复习","link":"/%E4%B8%93%E4%B8%9A%E5%A4%8D%E4%B9%A0/"},{"name":"博客文章","slug":"博客文章","link":"/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"name":"数学原理","slug":"数学原理","link":"/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"name":"数据结构","slug":"数据结构","link":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"pages":[]}